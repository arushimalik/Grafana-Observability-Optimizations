"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhmcclinic_skeleton_app"] = self["webpackChunkhmcclinic_skeleton_app"] || []).push([["pages_PageOne_tsx"],{

/***/ "./components/testIds.ts":
/*!*******************************!*\
  !*** ./components/testIds.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   testIds: () => (/* binding */ testIds)\n/* harmony export */ });\nconst testIds = {\n    appConfig: {\n        apiKey: 'data-testid ac-api-key',\n        apiUrl: 'data-testid ac-api-url',\n        submit: 'data-testid ac-submit-form'\n    },\n    pageOne: {\n        container: 'data-testid pg-one-container',\n        navigateToFour: 'data-testid navigate-to-four'\n    },\n    pageTwo: {\n        container: 'data-testid pg-two-container'\n    },\n    pageThree: {\n        container: 'data-testid pg-three-container'\n    },\n    pageFour: {\n        container: 'data-testid pg-four-container',\n        navigateBack: 'data-testid navigate-back'\n    },\n    pageUnused: {\n        container: 'data-testid pg-unused-container'\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL3Rlc3RJZHMudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLFVBQVU7SUFDckJDLFdBQVc7UUFDVEMsUUFBUTtRQUNSQyxRQUFRO1FBQ1JDLFFBQVE7SUFDVjtJQUNBQyxTQUFTO1FBQ1BDLFdBQVc7UUFDWEMsZ0JBQWdCO0lBQ2xCO0lBQ0FDLFNBQVM7UUFDUEYsV0FBVztJQUNiO0lBQ0FHLFdBQVc7UUFDVEgsV0FBVztJQUNiO0lBQ0FJLFVBQVU7UUFDUkosV0FBVztRQUNYSyxjQUFjO0lBQ2hCO0lBQ0FDLFlBQVk7UUFDVk4sV0FBVztJQUNiO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL2htY2NsaW5pYy1za2VsZXRvbi1hcHAvLi9jb21wb25lbnRzL3Rlc3RJZHMudHM/MDA1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdGVzdElkcyA9IHtcbiAgYXBwQ29uZmlnOiB7XG4gICAgYXBpS2V5OiAnZGF0YS10ZXN0aWQgYWMtYXBpLWtleScsXG4gICAgYXBpVXJsOiAnZGF0YS10ZXN0aWQgYWMtYXBpLXVybCcsXG4gICAgc3VibWl0OiAnZGF0YS10ZXN0aWQgYWMtc3VibWl0LWZvcm0nLFxuICB9LFxuICBwYWdlT25lOiB7XG4gICAgY29udGFpbmVyOiAnZGF0YS10ZXN0aWQgcGctb25lLWNvbnRhaW5lcicsXG4gICAgbmF2aWdhdGVUb0ZvdXI6ICdkYXRhLXRlc3RpZCBuYXZpZ2F0ZS10by1mb3VyJyxcbiAgfSxcbiAgcGFnZVR3bzoge1xuICAgIGNvbnRhaW5lcjogJ2RhdGEtdGVzdGlkIHBnLXR3by1jb250YWluZXInLFxuICB9LFxuICBwYWdlVGhyZWU6IHtcbiAgICBjb250YWluZXI6ICdkYXRhLXRlc3RpZCBwZy10aHJlZS1jb250YWluZXInLFxuICB9LFxuICBwYWdlRm91cjoge1xuICAgIGNvbnRhaW5lcjogJ2RhdGEtdGVzdGlkIHBnLWZvdXItY29udGFpbmVyJyxcbiAgICBuYXZpZ2F0ZUJhY2s6ICdkYXRhLXRlc3RpZCBuYXZpZ2F0ZS1iYWNrJyxcbiAgfSxcbiAgcGFnZVVudXNlZDoge1xuICAgIGNvbnRhaW5lcjogJ2RhdGEtdGVzdGlkIHBnLXVudXNlZC1jb250YWluZXInLFxuICB9LFxufTtcbiJdLCJuYW1lcyI6WyJ0ZXN0SWRzIiwiYXBwQ29uZmlnIiwiYXBpS2V5IiwiYXBpVXJsIiwic3VibWl0IiwicGFnZU9uZSIsImNvbnRhaW5lciIsIm5hdmlnYXRlVG9Gb3VyIiwicGFnZVR3byIsInBhZ2VUaHJlZSIsInBhZ2VGb3VyIiwibmF2aWdhdGVCYWNrIiwicGFnZVVudXNlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/testIds.ts\n");

/***/ }),

/***/ "./getServiceMetrics.tsx":
/*!*******************************!*\
  !*** ./getServiceMetrics.tsx ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getServiceMetrics: () => (/* binding */ getServiceMetrics),\n/* harmony export */   printTree: () => (/* binding */ printTree)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./constants.ts\");\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _async_to_generator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\n\nfunction getServiceMetrics(selectedService) {\n    return _getServiceMetrics.apply(this, arguments);\n}\nfunction _getServiceMetrics() {\n    _getServiceMetrics = _async_to_generator(function*(selectedService) {\n        // This function will take in a selected service as a string and return \n        // a list of all metrics (the leaves of the service metrics tree) and a tree structure for the whole metrics tree\n        try {\n            console.log(`Selected service: ${selectedService}`);\n            const response = yield fetch(`http://localhost:9080/metrics/find?query=${selectedService}.*`);\n            const services = yield response.json();\n            const flatList = [];\n            const tree = {};\n            // Function to build the tree and collect leaf metrics into the flat list\n            const buildTree = /*#__PURE__*/ function() {\n                var _ref = _async_to_generator(function*(service, treeNode) {\n                    if (service.leaf) {\n                        // Add leaf to flatList and tree\n                        if (!_constants__WEBPACK_IMPORTED_MODULE_0__.suffixSet.has(`.${service.text}`)) {\n                            // if the leaf text is not in the suffix set:\n                            flatList.push(service.id);\n                            treeNode[service.text] = null; // Leaf nodes in the tree are null\n                        }\n                    } else {\n                        // Create a new branch in the tree\n                        treeNode[service.text] = {};\n                        // Fetch children\n                        const childResponse = yield fetch(`http://localhost:9080/metrics/find?query=${service.id}.*`);\n                        const children = yield childResponse.json();\n                        if (children.length === 0) {\n                            // If no children, treat as a leaf\n                            flatList.push(service.id);\n                            treeNode[service.text] = null;\n                        } else {\n                            // Recursively process children\n                            yield Promise.all(children.map((child)=>buildTree(child, treeNode[service.text])));\n                            if (Object.keys(treeNode[service.text]).length === 0) {\n                                // check to see after we process all the children if any children remain. \n                                // if no children remain, this node is a leaf so treat it as one.\n                                treeNode[service.text] = null;\n                                flatList.push(service.id);\n                            }\n                        }\n                    }\n                });\n                return function buildTree(service, treeNode) {\n                    return _ref.apply(this, arguments);\n                };\n            }();\n            console.log(flatList);\n            // Build the tree and flat list by processing each root service\n            yield Promise.all(services.map((service)=>buildTree(service, tree)));\n            console.log(\"Flat List:\", flatList);\n            console.log(\"Tree Structure:\", tree);\n            return {\n                flatList,\n                tree\n            };\n        } catch (error) {\n            console.error(`Error fetching metrics for ${selectedService} from Graphite:`, error);\n            return {\n                flatList: [],\n                tree: {}\n            };\n        }\n    });\n    return _getServiceMetrics.apply(this, arguments);\n}\nfunction printTree(tree, indent = 0) {\n    const indentation = \"  \".repeat(indent); // Create indentation based on the depth of the node\n    for (const [key, value] of Object.entries(tree)){\n        if (value === null) {\n            // If it's a leaf node\n            console.log(`${indentation}- ${key}`);\n        } else {\n            // If it's a branch\n            console.log(`${indentation}+ ${key}`);\n            printTree(value, indent + 1); // Recurse into the branch\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QzdGLEtBQUssTUFBTSxDQUFDRyxLQUFLQyxNQUFNLElBQUlSLE9BQU9TLE9BQU8sQ0FBQ3pCLE1BQU87UUFDL0MsSUFBSXdCLFVBQVUsTUFBTTtZQUNsQixzQkFBc0I7WUFDdEIvQixRQUFRQyxHQUFHLENBQUMsQ0FBQyxFQUFFMkIsWUFBWSxFQUFFLEVBQUVFLElBQUksQ0FBQztRQUN0QyxPQUFPO1lBQ0wsbUJBQW1CO1lBQ25COUIsUUFBUUMsR0FBRyxDQUFDLENBQUMsRUFBRTJCLFlBQVksRUFBRSxFQUFFRSxJQUFJLENBQUM7WUFDcENKLFVBQVVLLE9BQU9KLFNBQVMsSUFBSSwwQkFBMEI7UUFDMUQ7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG1jY2xpbmljLXNrZWxldG9uLWFwcC8uL2dldFNlcnZpY2VNZXRyaWNzLnRzeD8yMjQ0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNlcnZpY2VSZXNwb25zZSwgc3VmZml4U2V0IH0gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U2VydmljZU1ldHJpY3Moc2VsZWN0ZWRTZXJ2aWNlOiBzdHJpbmcpOiBQcm9taXNlPHsgZmxhdExpc3Q6IHN0cmluZ1tdOyB0cmVlOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IH0+IHtcbiAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIHRha2UgaW4gYSBzZWxlY3RlZCBzZXJ2aWNlIGFzIGEgc3RyaW5nIGFuZCByZXR1cm4gXG4gIC8vIGEgbGlzdCBvZiBhbGwgbWV0cmljcyAodGhlIGxlYXZlcyBvZiB0aGUgc2VydmljZSBtZXRyaWNzIHRyZWUpIGFuZCBhIHRyZWUgc3RydWN0dXJlIGZvciB0aGUgd2hvbGUgbWV0cmljcyB0cmVlXG5cbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhgU2VsZWN0ZWQgc2VydmljZTogJHtzZWxlY3RlZFNlcnZpY2V9YCk7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGBodHRwOi8vbG9jYWxob3N0OjkwODAvbWV0cmljcy9maW5kP3F1ZXJ5PSR7c2VsZWN0ZWRTZXJ2aWNlfS4qYCk7XG4gICAgY29uc3Qgc2VydmljZXM6IFNlcnZpY2VSZXNwb25zZVtdID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgY29uc3QgZmxhdExpc3Q6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgdHJlZTogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9O1xuXG4gICAgLy8gRnVuY3Rpb24gdG8gYnVpbGQgdGhlIHRyZWUgYW5kIGNvbGxlY3QgbGVhZiBtZXRyaWNzIGludG8gdGhlIGZsYXQgbGlzdFxuICAgIGNvbnN0IGJ1aWxkVHJlZSA9IGFzeW5jIChzZXJ2aWNlOiBTZXJ2aWNlUmVzcG9uc2UsIHRyZWVOb2RlOiBhbnkpID0+IHtcbiAgICAgIGlmIChzZXJ2aWNlLmxlYWYpIHtcbiAgICAgICAgLy8gQWRkIGxlYWYgdG8gZmxhdExpc3QgYW5kIHRyZWVcbiAgICAgICAgaWYgKCFzdWZmaXhTZXQuaGFzKGAuJHtzZXJ2aWNlLnRleHR9YCkpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgbGVhZiB0ZXh0IGlzIG5vdCBpbiB0aGUgc3VmZml4IHNldDpcbiAgICAgICAgICBmbGF0TGlzdC5wdXNoKHNlcnZpY2UuaWQpO1xuICAgICAgICAgIHRyZWVOb2RlW3NlcnZpY2UudGV4dF0gPSBudWxsOyAvLyBMZWFmIG5vZGVzIGluIHRoZSB0cmVlIGFyZSBudWxsXG4gICAgICAgIH0gXG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBicmFuY2ggaW4gdGhlIHRyZWVcbiAgICAgICAgdHJlZU5vZGVbc2VydmljZS50ZXh0XSA9IHt9O1xuXG4gICAgICAgIC8vIEZldGNoIGNoaWxkcmVuXG4gICAgICAgIGNvbnN0IGNoaWxkUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgaHR0cDovL2xvY2FsaG9zdDo5MDgwL21ldHJpY3MvZmluZD9xdWVyeT0ke3NlcnZpY2UuaWR9LipgKTtcbiAgICAgICAgY29uc3QgY2hpbGRyZW46IFNlcnZpY2VSZXNwb25zZVtdID0gYXdhaXQgY2hpbGRSZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIC8vIElmIG5vIGNoaWxkcmVuLCB0cmVhdCBhcyBhIGxlYWZcbiAgICAgICAgICBmbGF0TGlzdC5wdXNoKHNlcnZpY2UuaWQpO1xuICAgICAgICAgIHRyZWVOb2RlW3NlcnZpY2UudGV4dF0gPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHByb2Nlc3MgY2hpbGRyZW5cbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChjaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiBidWlsZFRyZWUoY2hpbGQsIHRyZWVOb2RlW3NlcnZpY2UudGV4dF0pKSk7XG5cbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXModHJlZU5vZGVbc2VydmljZS50ZXh0XSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBjaGVjayB0byBzZWUgYWZ0ZXIgd2UgcHJvY2VzcyBhbGwgdGhlIGNoaWxkcmVuIGlmIGFueSBjaGlsZHJlbiByZW1haW4uIFxuICAgICAgICAgICAgLy8gaWYgbm8gY2hpbGRyZW4gcmVtYWluLCB0aGlzIG5vZGUgaXMgYSBsZWFmIHNvIHRyZWF0IGl0IGFzIG9uZS5cbiAgICAgICAgICAgIHRyZWVOb2RlW3NlcnZpY2UudGV4dF0gPSBudWxsO1xuICAgICAgICAgICAgZmxhdExpc3QucHVzaChzZXJ2aWNlLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnNvbGUubG9nKGZsYXRMaXN0KTtcbiAgICAvLyBCdWlsZCB0aGUgdHJlZSBhbmQgZmxhdCBsaXN0IGJ5IHByb2Nlc3NpbmcgZWFjaCByb290IHNlcnZpY2VcbiAgICBhd2FpdCBQcm9taXNlLmFsbChzZXJ2aWNlcy5tYXAoKHNlcnZpY2UpID0+IGJ1aWxkVHJlZShzZXJ2aWNlLCB0cmVlKSkpO1xuXG4gICAgY29uc29sZS5sb2coXCJGbGF0IExpc3Q6XCIsIGZsYXRMaXN0KTtcbiAgICBjb25zb2xlLmxvZyhcIlRyZWUgU3RydWN0dXJlOlwiLCB0cmVlKTtcblxuICAgIHJldHVybiB7IGZsYXRMaXN0LCB0cmVlIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgbWV0cmljcyBmb3IgJHtzZWxlY3RlZFNlcnZpY2V9IGZyb20gR3JhcGhpdGU6YCwgZXJyb3IpO1xuICAgIHJldHVybiB7IGZsYXRMaXN0OiBbXSwgdHJlZToge30gfTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJpbnRUcmVlICh0cmVlOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBpbmRlbnQgPSAwKTogdm9pZCB7XG4gIGNvbnN0IGluZGVudGF0aW9uID0gXCIgIFwiLnJlcGVhdChpbmRlbnQpOyAvLyBDcmVhdGUgaW5kZW50YXRpb24gYmFzZWQgb24gdGhlIGRlcHRoIG9mIHRoZSBub2RlXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHRyZWUpKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAvLyBJZiBpdCdzIGEgbGVhZiBub2RlXG4gICAgICBjb25zb2xlLmxvZyhgJHtpbmRlbnRhdGlvbn0tICR7a2V5fWApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBpdCdzIGEgYnJhbmNoXG4gICAgICBjb25zb2xlLmxvZyhgJHtpbmRlbnRhdGlvbn0rICR7a2V5fWApO1xuICAgICAgcHJpbnRUcmVlKHZhbHVlLCBpbmRlbnQgKyAxKTsgLy8gUmVjdXJzZSBpbnRvIHRoZSBicmFuY2hcbiAgICB9XG4gIH1cbn07XG4iXSwibmFtZXMiOlsic3VmZml4U2V0IiwiZ2V0U2VydmljZU1ldHJpY3MiLCJzZWxlY3RlZFNlcnZpY2UiLCJjb25zb2xlIiwibG9nIiwicmVzcG9uc2UiLCJmZXRjaCIsInNlcnZpY2VzIiwianNvbiIsImZsYXRMaXN0IiwidHJlZSIsImJ1aWxkVHJlZSIsInNlcnZpY2UiLCJ0cmVlTm9kZSIsImxlYWYiLCJoYXMiLCJ0ZXh0IiwicHVzaCIsImlkIiwiY2hpbGRSZXNwb25zZSIsImNoaWxkcmVuIiwibGVuZ3RoIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsImNoaWxkIiwiT2JqZWN0Iiwia2V5cyIsImVycm9yIiwicHJpbnRUcmVlIiwiaW5kZW50IiwiaW5kZW50YXRpb24iLCJyZXBlYXQiLCJrZXkiLCJ2YWx1ZSIsImVudHJpZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./getServiceMetrics.tsx\n");

/***/ }),

/***/ "./pages/PageOne.tsx":
/*!***************************!*\
  !*** ./pages/PageOne.tsx ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @emotion/css */ \"@emotion/css\");\n/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_emotion_css__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @grafana/ui */ \"@grafana/ui\");\n/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _utils_utils_routing__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/utils.routing */ \"./utils/utils.routing.ts\");\n/* harmony import */ var _components_testIds__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/testIds */ \"./components/testIds.ts\");\n/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @grafana/runtime */ \"@grafana/runtime\");\n/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_grafana_runtime__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _getServiceMetrics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../getServiceMetrics */ \"./getServiceMetrics.tsx\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../constants */ \"./constants.ts\");\n/* harmony import */ var react_icons_vsc__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react-icons/vsc */ \"../node_modules/react-icons/vsc/index.mjs\");\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _async_to_generator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\n\n\n\n\n\n\n\n\n\nfunction PageOne() {\n    const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);\n    // State for selected options and available options\n    const [selectedService, setSelectedService] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [selectedDashboard, setSelectedDashboard] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [availableServices, setAvailableServices] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [availableDashboards, setAvailableDashboards] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loadingServices, setLoadingServices] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [loadingDashboards, setLoadingDashboards] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [serviceError, setServiceError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [dashboardError, setDashboardError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [metricComparison, setMetricComparison] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        fetchAvailableServices();\n        fetchAvailableDashboards();\n    }, []);\n    const fetchAvailableServices = /*#__PURE__*/ function() {\n        var _ref = _async_to_generator(function*() {\n            setLoadingServices(true);\n            setServiceError(null);\n            try {\n                const response = yield fetch('http://localhost:9080/metrics/find?query=*'); // TODO: THIS SHOULD NOT BE HARDCODED. FIX THIS.\n                const services = yield response.json();\n                const formattedServices = services.map((service)=>({\n                        label: service.text,\n                        value: service.text\n                    }));\n                setAvailableServices(formattedServices);\n            } catch (error) {\n                console.error('Error fetching services from Graphite:', error);\n                setServiceError('Failed to load services');\n            } finally{\n                setLoadingServices(false);\n            }\n        });\n        return function fetchAvailableServices() {\n            return _ref.apply(this, arguments);\n        };\n    }();\n    const fetchAvailableDashboards = /*#__PURE__*/ function() {\n        var _ref = _async_to_generator(function*() {\n            setLoadingDashboards(true);\n            setDashboardError(null);\n            try {\n                const dashboards = yield (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_5__.getBackendSrv)().get('/api/search');\n                const formattedDashboards = dashboards.map((dash)=>({\n                        label: dash.title,\n                        value: dash.uid\n                    }));\n                setAvailableDashboards(formattedDashboards);\n            } catch (error) {\n                console.error('Error fetching dashboards:', error);\n                setDashboardError('Failed to load dashboards');\n            } finally{\n                setLoadingDashboards(false);\n            }\n        });\n        return function fetchAvailableDashboards() {\n            return _ref.apply(this, arguments);\n        };\n    }();\n    function getUsedMetrics() {\n        return _getUsedMetrics.apply(this, arguments);\n    }\n    function _getUsedMetrics() {\n        _getUsedMetrics = _async_to_generator(function*() {\n            if (!selectedService || !selectedDashboard) {\n                console.error(\"Required selections or formatted metrics are missing.\");\n                return;\n            }\n            // Fetch the selected dashboard data to get metrics\n            const dashboard = yield (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_5__.getBackendSrv)().get(`/api/dashboards/uid/${selectedDashboard.value}`);\n            const dashboardPanels = dashboard.dashboard.panels || [];\n            let usedMetricsSet = new Set();\n            dashboardPanels.forEach((panel)=>{\n                if (panel.targets && Array.isArray(panel.targets)) {\n                    panel.targets.forEach((target)=>{\n                        if (target.target) {\n                            let targetMetric = target.target;\n                            // Regular expression to match any function at the start, followed by a metric name\n                            const functionRegex = /^[a-zA-Z0-9_]+\\((.*?)\\)$/;\n                            // If the target metric starts with a function, remove it and retain the metric name\n                            const match = targetMetric.match(functionRegex);\n                            if (match) {\n                                // Extract the part inside the parentheses (the actual metric name)\n                                targetMetric = match[1];\n                            }\n                            // Use regex to check if the target metric belongs to the selected service\n                            const serviceRegex = new RegExp(`(^|[^a-zA-Z0-9_])${selectedService.value}([^a-zA-Z0-9_]|$)`);\n                            if (serviceRegex.test(targetMetric)) {\n                                usedMetricsSet.add(targetMetric); // Add the metric without the function wrapper\n                            }\n                        }\n                    });\n                }\n            });\n            // Compare available metrics with the used metrics\n            let usedMetricsArray = Array.from(usedMetricsSet);\n            usedMetricsArray = removeRedundantSuffixes(usedMetricsArray);\n            console.log(`used Metrics Array ${usedMetricsArray}`);\n            return usedMetricsArray;\n        });\n        return _getUsedMetrics.apply(this, arguments);\n    }\n    function compareMetrics(formattedMetrics, metricTree) {\n        return _compareMetrics.apply(this, arguments);\n    }\n    function _compareMetrics() {\n        _compareMetrics = _async_to_generator(function*(formattedMetrics, metricTree) {\n            if (!selectedService || !selectedDashboard || !formattedMetrics) {\n                console.error(\"Required selections or formatted metrics are missing.\");\n                return;\n            }\n            try {\n                // Fetch available metrics\n                const availableMetrics = formattedMetrics;\n                console.log(\"Available Metrics:\", availableMetrics);\n                // Fetch used metrics\n                let usedMetrics = yield getUsedMetrics();\n                if (!usedMetrics) {\n                    usedMetrics = [];\n                }\n                console.log(`Used Metrics ${usedMetrics}`);\n                let unusedMetrics = new Array();\n                // Helper function to check if a metric matches any of the used metrics (with wildcard support)\n                const matchesUsedMetric = (metric, usedMetrics)=>{\n                    return usedMetrics.some((usedMetric)=>{\n                        try {\n                            const regexPattern = `^${usedMetric.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*')}$`;\n                            const regex = new RegExp(regexPattern);\n                            console.log(`Tested regex pattern ${regexPattern} on ${metric}, ${regex.test(metric)}`);\n                            return regex.test(metric);\n                        } catch (error) {\n                            console.error(\"Invalid regex in used metric:\", usedMetric, error);\n                            return false;\n                        }\n                    });\n                };\n                // Recursive function to traverse the metric tree\n                const traverseTree = (node, currentPath)=>{\n                    for(const key in node){\n                        const newPath = currentPath ? `${currentPath}.${key}` : key;\n                        if (node[key] === null) {\n                            // It's a leaf node\n                            if (!matchesUsedMetric(newPath, usedMetrics)) {\n                                unusedMetrics.push(newPath);\n                            }\n                        } else {\n                            // It's a branch; recurse into it\n                            traverseTree(node[key], newPath);\n                        }\n                    }\n                };\n                // Start traversing from the root of the metric tree\n                traverseTree(metricTree, selectedService.value);\n                console.log(\"Unused Metrics:\", unusedMetrics);\n                // Set the comparison result\n                setMetricComparison({\n                    usedMetrics: usedMetrics,\n                    unusedMetrics: unusedMetrics\n                });\n            } catch (error) {\n                console.error(\"Error comparing metrics:\", error);\n            }\n        });\n        return _compareMetrics.apply(this, arguments);\n    }\n    ;\n    // Trigger comparison when both service and dashboard are selected\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const fetchAndCompareMetrics = /*#__PURE__*/ function() {\n            var _ref = _async_to_generator(function*() {\n                if (selectedService && selectedDashboard) {\n                    try {\n                        const result = yield (0,_getServiceMetrics__WEBPACK_IMPORTED_MODULE_6__.getServiceMetrics)(selectedService.label); // Fetch formatted metrics\n                        const formattedMetrics = result.flatList;\n                        const treeMetrics = result.tree;\n                        (0,_getServiceMetrics__WEBPACK_IMPORTED_MODULE_6__.printTree)(treeMetrics);\n                        yield compareMetrics(formattedMetrics, treeMetrics); // Compare metrics\n                    } catch (error) {\n                        console.error('Error in fetching or comparing metrics:', error);\n                    }\n                }\n            });\n            return function fetchAndCompareMetrics() {\n                return _ref.apply(this, arguments);\n            };\n        }();\n        fetchAndCompareMetrics();\n    }, [\n        selectedService,\n        selectedDashboard\n    ]);\n    const removeRedundantSuffixes = (metrics)=>{\n        // removes redundant suffixes from metric names\n        const groupedMetrics = new Set();\n        metrics.forEach((label)=>{\n            for (let suffix of _constants__WEBPACK_IMPORTED_MODULE_7__.suffixSet){\n                if (label.endsWith(suffix)) {\n                    const prefix = label.slice(0, label.length - suffix.length);\n                    if (!groupedMetrics.has(prefix)) {\n                        groupedMetrics.add(prefix);\n                    }\n                    break; // Only match one suffix\n                }\n            }\n        });\n        // Build new Option objects with formatted labels\n        const formattedMetrics = [];\n        groupedMetrics.forEach((prefix)=>{\n            formattedMetrics.push(prefix);\n        });\n        return formattedMetrics;\n    };\n    // take in a flat list of metrics and format them as a tree structure\n    const formatAsTree = (metrics)=>{\n        const tree = {};\n        metrics.forEach((metric)=>{\n            const parts = metric.split('.');\n            let currentLevel = tree;\n            parts.forEach((part, index)=>{\n                if (!currentLevel[part]) {\n                    currentLevel[part] = index === parts.length - 1 ? null : {};\n                }\n                currentLevel = currentLevel[part];\n            });\n        });\n        return tree;\n    };\n    // Tree Node Component in React (for rendering expandable lists)\n    const TreeNode = ({ label, children })=>{\n        const [isExpanded, setIsExpanded] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n        const toggleExpansion = ()=>{\n            setIsExpanded(!isExpanded);\n        };\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            style: {\n                marginLeft: '20px'\n            }\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            onClick: toggleExpansion,\n            style: {\n                cursor: 'pointer',\n                fontWeight: children ? 'bold' : 'normal'\n            }\n        }, children ? isExpanded ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_icons_vsc__WEBPACK_IMPORTED_MODULE_8__.VscChevronRight, null) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_icons_vsc__WEBPACK_IMPORTED_MODULE_8__.VscChevronDown, null) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_icons_vsc__WEBPACK_IMPORTED_MODULE_8__.VscIndent, null), \" \", label), isExpanded && children && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", null, children));\n    };\n    const Tree = ({ data })=>{\n        const renderTree = (node)=>{\n            return Object.keys(node).map((key)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(TreeNode, {\n                    key: key,\n                    label: key\n                }, node[key] !== null && typeof node[key] === 'object' ? renderTree(node[key]) : null));\n        };\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", null, renderTree(data));\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_runtime__WEBPACK_IMPORTED_MODULE_5__.PluginPage, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        \"data-testid\": _components_testIds__WEBPACK_IMPORTED_MODULE_4__.testIds.pageOne.container\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        className: styles.marginTop\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Select, {\n        options: availableServices,\n        value: selectedService,\n        onChange: setSelectedService,\n        placeholder: \"Select Service\",\n        isLoading: loadingServices\n    }), serviceError && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        className: styles.error\n    }, serviceError)), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        className: styles.marginTop\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Select, {\n        options: availableDashboards,\n        value: selectedDashboard,\n        onChange: setSelectedDashboard,\n        placeholder: \"Select Dashboard\",\n        isLoading: loadingDashboards\n    }), dashboardError && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        className: styles.error\n    }, dashboardError)), metricComparison && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        className: styles.marginTop\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"h4\", null, \"Metric Comparison:\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"strong\", null, \"Used Metrics:\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"ul\", null, metricComparison.usedMetrics && metricComparison.usedMetrics.length > 0 ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Tree, {\n        data: formatAsTree(metricComparison.usedMetrics)\n    }) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"p\", null, \"No used metrics.\"))), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"strong\", null, \"Unused Metrics:\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"ul\", null, metricComparison.unusedMetrics && metricComparison.unusedMetrics.length > 0 ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Tree, {\n        data: formatAsTree(metricComparison.unusedMetrics)\n    }) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"p\", null, \"No unused metrics.\")))), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        className: styles.marginTop\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.LinkButton, {\n        \"data-testid\": _components_testIds__WEBPACK_IMPORTED_MODULE_4__.testIds.pageOne.navigateToFour,\n        href: (0,_utils_utils_routing__WEBPACK_IMPORTED_MODULE_3__.prefixRoute)(_constants__WEBPACK_IMPORTED_MODULE_7__.ROUTES.Four)\n    }, \"Full-width page example\"))));\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PageOne);\n// Styles\nconst getStyles = (theme)=>({\n        marginTop: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_1__.css)`\n    margin-top: ${theme.spacing(2)};\n  `,\n        error: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_1__.css)`\n    color: ${theme.colors.error.text};\n    margin-top: ${theme.spacing(1)};\n  `\n    });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUcscUNBQ0osMkRBQUNwQiwyQkFDQywyREFBQ3FCLGdCQUFPLGdDQUNSLDJEQUFDQyxZQUlFOUcsaUJBQWlCaUQsV0FBVyxJQUFJakQsaUJBQWlCaUQsV0FBVyxDQUFDMEIsTUFBTSxHQUFHLGtCQUNyRSwyREFBQ21CO1FBQUtDLE1BQU1sQixhQUFhN0UsaUJBQWlCaUQsV0FBVzt1QkFFckQsMkRBQUM4RCxXQUFFLHFDQUlULDJEQUFDdkIsMkJBQ0MsMkRBQUNxQixnQkFBTyxrQ0FDUiwyREFBQ0MsWUFJRTlHLGlCQUFpQmtELGFBQWEsSUFBSWxELGlCQUFpQmtELGFBQWEsQ0FBQ3lCLE1BQU0sR0FBRyxrQkFDekUsMkRBQUNtQjtRQUFLQyxNQUFNbEIsYUFBYTdFLGlCQUFpQmtELGFBQWE7dUJBRXZELDJEQUFDNkQsV0FBRSx3Q0FPYiwyREFBQ3ZCO1FBQUljLFdBQVd4SCxPQUFPeUgsU0FBUztxQkFDOUIsMkRBQUN4SSxtREFBVUE7UUFBQ29JLGVBQWFoSSx3REFBT0EsQ0FBQ2lJLE9BQU8sQ0FBQ1ksY0FBYztRQUFFQyxNQUFNL0ksaUVBQVdBLENBQUNNLDhDQUFNQSxDQUFDMEksSUFBSTtPQUFHO0FBT25HO0FBRUEsaUVBQWVySSxPQUFPQSxFQUFDO0FBRXZCLFNBQVM7QUFDVCxNQUFNRSxZQUFZLENBQUNvSSxRQUEwQjtRQUMzQ1osV0FBV3pJLGlEQUFHLENBQUM7Z0JBQ0QsRUFBRXFKLE1BQU1DLE9BQU8sQ0FBQyxHQUFHO0VBQ2pDLENBQUM7UUFDRHRHLE9BQU9oRCxpREFBRyxDQUFDO1dBQ0YsRUFBRXFKLE1BQU1FLE1BQU0sQ0FBQ3ZHLEtBQUssQ0FBQ0YsSUFBSSxDQUFDO2dCQUNyQixFQUFFdUcsTUFBTUMsT0FBTyxDQUFDLEdBQUc7RUFDakMsQ0FBQztJQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG1jY2xpbmljLXNrZWxldG9uLWFwcC8uL3BhZ2VzL1BhZ2VPbmUudHN4PzJmZjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAZW1vdGlvbi9jc3MnO1xuaW1wb3J0IHsgR3JhZmFuYVRoZW1lMiB9IGZyb20gJ0BncmFmYW5hL2RhdGEnO1xuaW1wb3J0IHsgTGlua0J1dHRvbiwgdXNlU3R5bGVzMiwgU2VsZWN0IH0gZnJvbSAnQGdyYWZhbmEvdWknO1xuaW1wb3J0IHsgcHJlZml4Um91dGUgfSBmcm9tICcuLi91dGlscy91dGlscy5yb3V0aW5nJztcbmltcG9ydCB7IHRlc3RJZHMgfSBmcm9tICcuLi9jb21wb25lbnRzL3Rlc3RJZHMnO1xuaW1wb3J0IHsgUGx1Z2luUGFnZSwgZ2V0QmFja2VuZFNydiB9IGZyb20gJ0BncmFmYW5hL3J1bnRpbWUnO1xuaW1wb3J0IHsgZ2V0U2VydmljZU1ldHJpY3MsIHByaW50VHJlZSB9IGZyb20gJ2dldFNlcnZpY2VNZXRyaWNzJztcbmltcG9ydCB7IFJPVVRFUywgT3B0aW9uLCBTZXJ2aWNlUmVzcG9uc2UsIERhc2hib2FyZFJlc3BvbnNlLCBNZXRyaWNDb21wYXJpc29uLCBzdWZmaXhTZXQgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5pbXBvcnQgeyBWc2NDaGV2cm9uRG93biwgVnNjQ2hldnJvblJpZ2h0LCBWc2NJbmRlbnQgfSBmcm9tIFwicmVhY3QtaWNvbnMvdnNjXCI7XG5cbmZ1bmN0aW9uIFBhZ2VPbmUoKSB7XG4gIGNvbnN0IHN0eWxlcyA9IHVzZVN0eWxlczIoZ2V0U3R5bGVzKTtcblxuICAvLyBTdGF0ZSBmb3Igc2VsZWN0ZWQgb3B0aW9ucyBhbmQgYXZhaWxhYmxlIG9wdGlvbnNcbiAgY29uc3QgW3NlbGVjdGVkU2VydmljZSwgc2V0U2VsZWN0ZWRTZXJ2aWNlXSA9IHVzZVN0YXRlPE9wdGlvbiB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbc2VsZWN0ZWREYXNoYm9hcmQsIHNldFNlbGVjdGVkRGFzaGJvYXJkXSA9IHVzZVN0YXRlPE9wdGlvbiB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbYXZhaWxhYmxlU2VydmljZXMsIHNldEF2YWlsYWJsZVNlcnZpY2VzXSA9IHVzZVN0YXRlPE9wdGlvbltdPihbXSk7XG4gIGNvbnN0IFthdmFpbGFibGVEYXNoYm9hcmRzLCBzZXRBdmFpbGFibGVEYXNoYm9hcmRzXSA9IHVzZVN0YXRlPE9wdGlvbltdPihbXSk7XG4gIGNvbnN0IFtsb2FkaW5nU2VydmljZXMsIHNldExvYWRpbmdTZXJ2aWNlc10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtsb2FkaW5nRGFzaGJvYXJkcywgc2V0TG9hZGluZ0Rhc2hib2FyZHNdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2VydmljZUVycm9yLCBzZXRTZXJ2aWNlRXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtkYXNoYm9hcmRFcnJvciwgc2V0RGFzaGJvYXJkRXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFttZXRyaWNDb21wYXJpc29uLCBzZXRNZXRyaWNDb21wYXJpc29uXSA9IHVzZVN0YXRlPE1ldHJpY0NvbXBhcmlzb24gfCBudWxsPihudWxsKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGZldGNoQXZhaWxhYmxlU2VydmljZXMoKTtcbiAgICBmZXRjaEF2YWlsYWJsZURhc2hib2FyZHMoKTtcbiAgfSwgW10pO1xuICBcblxuICBjb25zdCBmZXRjaEF2YWlsYWJsZVNlcnZpY2VzID0gYXN5bmMgKCkgPT4ge1xuICAgIHNldExvYWRpbmdTZXJ2aWNlcyh0cnVlKTtcbiAgICBzZXRTZXJ2aWNlRXJyb3IobnVsbCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHA6Ly9sb2NhbGhvc3Q6OTA4MC9tZXRyaWNzL2ZpbmQ/cXVlcnk9KicpOyAvLyBUT0RPOiBUSElTIFNIT1VMRCBOT1QgQkUgSEFSRENPREVELiBGSVggVEhJUy5cbiAgICAgIGNvbnN0IHNlcnZpY2VzOiBTZXJ2aWNlUmVzcG9uc2VbXSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnN0IGZvcm1hdHRlZFNlcnZpY2VzID0gc2VydmljZXMubWFwKChzZXJ2aWNlKSA9PiAoe1xuICAgICAgICBsYWJlbDogc2VydmljZS50ZXh0LFxuICAgICAgICB2YWx1ZTogc2VydmljZS50ZXh0LFxuICAgICAgfSkpO1xuICAgICAgc2V0QXZhaWxhYmxlU2VydmljZXMoZm9ybWF0dGVkU2VydmljZXMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBzZXJ2aWNlcyBmcm9tIEdyYXBoaXRlOicsIGVycm9yKTtcbiAgICAgIHNldFNlcnZpY2VFcnJvcignRmFpbGVkIHRvIGxvYWQgc2VydmljZXMnKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZ1NlcnZpY2VzKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgZmV0Y2hBdmFpbGFibGVEYXNoYm9hcmRzID0gYXN5bmMgKCkgPT4ge1xuICAgIHNldExvYWRpbmdEYXNoYm9hcmRzKHRydWUpO1xuICAgIHNldERhc2hib2FyZEVycm9yKG51bGwpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXNoYm9hcmRzOiBEYXNoYm9hcmRSZXNwb25zZVtdID0gYXdhaXQgZ2V0QmFja2VuZFNydigpLmdldCgnL2FwaS9zZWFyY2gnKTtcbiAgICAgIGNvbnN0IGZvcm1hdHRlZERhc2hib2FyZHMgPSBkYXNoYm9hcmRzLm1hcCgoZGFzaCkgPT4gKHtcbiAgICAgICAgbGFiZWw6IGRhc2gudGl0bGUsXG4gICAgICAgIHZhbHVlOiBkYXNoLnVpZCxcbiAgICAgIH0pKTtcbiAgICAgIHNldEF2YWlsYWJsZURhc2hib2FyZHMoZm9ybWF0dGVkRGFzaGJvYXJkcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGRhc2hib2FyZHM6JywgZXJyb3IpO1xuICAgICAgc2V0RGFzaGJvYXJkRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGRhc2hib2FyZHMnKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZ0Rhc2hib2FyZHMoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBhc3luYyBmdW5jdGlvbiBnZXRVc2VkTWV0cmljcygpIHtcbiAgICBpZiAoIXNlbGVjdGVkU2VydmljZSB8fCAhc2VsZWN0ZWREYXNoYm9hcmQgKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiUmVxdWlyZWQgc2VsZWN0aW9ucyBvciBmb3JtYXR0ZWQgbWV0cmljcyBhcmUgbWlzc2luZy5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEZldGNoIHRoZSBzZWxlY3RlZCBkYXNoYm9hcmQgZGF0YSB0byBnZXQgbWV0cmljc1xuICAgIGNvbnN0IGRhc2hib2FyZCA9IGF3YWl0IGdldEJhY2tlbmRTcnYoKS5nZXQoYC9hcGkvZGFzaGJvYXJkcy91aWQvJHtzZWxlY3RlZERhc2hib2FyZC52YWx1ZX1gKTtcbiAgICBjb25zdCBkYXNoYm9hcmRQYW5lbHMgPSBkYXNoYm9hcmQuZGFzaGJvYXJkLnBhbmVscyB8fCBbXTtcblxuICAgIGxldCB1c2VkTWV0cmljc1NldDogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7XG5cbiAgICBkYXNoYm9hcmRQYW5lbHMuZm9yRWFjaCgocGFuZWw6IGFueSkgPT4ge1xuICAgICAgaWYgKHBhbmVsLnRhcmdldHMgJiYgQXJyYXkuaXNBcnJheShwYW5lbC50YXJnZXRzKSkge1xuICAgICAgICBwYW5lbC50YXJnZXRzLmZvckVhY2goKHRhcmdldDogYW55KSA9PiB7XG4gICAgICAgICAgaWYgKHRhcmdldC50YXJnZXQpIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXRNZXRyaWMgPSB0YXJnZXQudGFyZ2V0O1xuICAgIFxuICAgICAgICAgICAgLy8gUmVndWxhciBleHByZXNzaW9uIHRvIG1hdGNoIGFueSBmdW5jdGlvbiBhdCB0aGUgc3RhcnQsIGZvbGxvd2VkIGJ5IGEgbWV0cmljIG5hbWVcbiAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uUmVnZXggPSAvXlthLXpBLVowLTlfXStcXCgoLio/KVxcKSQvO1xuICAgIFxuICAgICAgICAgICAgLy8gSWYgdGhlIHRhcmdldCBtZXRyaWMgc3RhcnRzIHdpdGggYSBmdW5jdGlvbiwgcmVtb3ZlIGl0IGFuZCByZXRhaW4gdGhlIG1ldHJpYyBuYW1lXG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHRhcmdldE1ldHJpYy5tYXRjaChmdW5jdGlvblJlZ2V4KTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBwYXJ0IGluc2lkZSB0aGUgcGFyZW50aGVzZXMgKHRoZSBhY3R1YWwgbWV0cmljIG5hbWUpXG4gICAgICAgICAgICAgIHRhcmdldE1ldHJpYyA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gVXNlIHJlZ2V4IHRvIGNoZWNrIGlmIHRoZSB0YXJnZXQgbWV0cmljIGJlbG9uZ3MgdG8gdGhlIHNlbGVjdGVkIHNlcnZpY2VcbiAgICAgICAgICAgIGNvbnN0IHNlcnZpY2VSZWdleCA9IG5ldyBSZWdFeHAoYChefFteYS16QS1aMC05X10pJHtzZWxlY3RlZFNlcnZpY2UudmFsdWV9KFteYS16QS1aMC05X118JClgKTtcbiAgICAgICAgICAgIGlmIChzZXJ2aWNlUmVnZXgudGVzdCh0YXJnZXRNZXRyaWMpKSB7XG4gICAgICAgICAgICAgIHVzZWRNZXRyaWNzU2V0LmFkZCh0YXJnZXRNZXRyaWMpOyAgLy8gQWRkIHRoZSBtZXRyaWMgd2l0aG91dCB0aGUgZnVuY3Rpb24gd3JhcHBlclxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gQ29tcGFyZSBhdmFpbGFibGUgbWV0cmljcyB3aXRoIHRoZSB1c2VkIG1ldHJpY3NcbiAgICBsZXQgdXNlZE1ldHJpY3NBcnJheSA9IEFycmF5LmZyb20odXNlZE1ldHJpY3NTZXQpO1xuICAgIHVzZWRNZXRyaWNzQXJyYXkgPSByZW1vdmVSZWR1bmRhbnRTdWZmaXhlcyh1c2VkTWV0cmljc0FycmF5KTtcblxuICAgIGNvbnNvbGUubG9nKGB1c2VkIE1ldHJpY3MgQXJyYXkgJHt1c2VkTWV0cmljc0FycmF5fWApO1xuICAgIHJldHVybiB1c2VkTWV0cmljc0FycmF5O1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gY29tcGFyZU1ldHJpY3MoZm9ybWF0dGVkTWV0cmljczogc3RyaW5nW10sIG1ldHJpY1RyZWU6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXNlbGVjdGVkU2VydmljZSB8fCAhc2VsZWN0ZWREYXNoYm9hcmQgfHwgIWZvcm1hdHRlZE1ldHJpY3MpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJSZXF1aXJlZCBzZWxlY3Rpb25zIG9yIGZvcm1hdHRlZCBtZXRyaWNzIGFyZSBtaXNzaW5nLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIFxuICAgIHRyeSB7XG4gICAgICAvLyBGZXRjaCBhdmFpbGFibGUgbWV0cmljc1xuICAgICAgY29uc3QgYXZhaWxhYmxlTWV0cmljcyA9IGZvcm1hdHRlZE1ldHJpY3M7XG4gICAgICBjb25zb2xlLmxvZyhcIkF2YWlsYWJsZSBNZXRyaWNzOlwiLCBhdmFpbGFibGVNZXRyaWNzKTtcbiAgXG4gICAgICAvLyBGZXRjaCB1c2VkIG1ldHJpY3NcbiAgICAgIGxldCB1c2VkTWV0cmljcyA9IGF3YWl0IGdldFVzZWRNZXRyaWNzKCk7XG4gICAgICBpZiAoIXVzZWRNZXRyaWNzKSB7XG4gICAgICAgIHVzZWRNZXRyaWNzID0gW107XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKGBVc2VkIE1ldHJpY3MgJHt1c2VkTWV0cmljc31gKTtcblxuICAgICAgbGV0IHVudXNlZE1ldHJpY3M6c3RyaW5nW10gPSBuZXcgQXJyYXkoKTtcblxuICAgICAgXG4gICAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY2hlY2sgaWYgYSBtZXRyaWMgbWF0Y2hlcyBhbnkgb2YgdGhlIHVzZWQgbWV0cmljcyAod2l0aCB3aWxkY2FyZCBzdXBwb3J0KVxuICAgICAgY29uc3QgbWF0Y2hlc1VzZWRNZXRyaWMgPSAobWV0cmljOiBzdHJpbmcsIHVzZWRNZXRyaWNzOiBzdHJpbmdbXSk6IGJvb2xlYW4gPT4ge1xuICAgICAgICByZXR1cm4gdXNlZE1ldHJpY3Muc29tZSgodXNlZE1ldHJpYykgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZWdleFBhdHRlcm4gPSBgXiR7dXNlZE1ldHJpYy5yZXBsYWNlKC9cXC4vZywgJ1xcXFwuJykucmVwbGFjZSgvXFwqL2csICcuKicpfSRgO1xuICAgICAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4UGF0dGVybik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgVGVzdGVkIHJlZ2V4IHBhdHRlcm4gJHtyZWdleFBhdHRlcm59IG9uICR7bWV0cmljfSwgJHtyZWdleC50ZXN0KG1ldHJpYyl9YCk7XG4gICAgICAgICAgICByZXR1cm4gcmVnZXgudGVzdChtZXRyaWMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCByZWdleCBpbiB1c2VkIG1ldHJpYzpcIiwgdXNlZE1ldHJpYywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBSZWN1cnNpdmUgZnVuY3Rpb24gdG8gdHJhdmVyc2UgdGhlIG1ldHJpYyB0cmVlXG4gICAgICBjb25zdCB0cmF2ZXJzZVRyZWUgPSAobm9kZTogUmVjb3JkPHN0cmluZywgYW55PiwgY3VycmVudFBhdGg6IHN0cmluZykgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBub2RlKSB7XG4gICAgICAgICAgY29uc3QgbmV3UGF0aCA9IGN1cnJlbnRQYXRoID8gYCR7Y3VycmVudFBhdGh9LiR7a2V5fWAgOiBrZXk7XG5cbiAgICAgICAgICBpZiAobm9kZVtrZXldID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJdCdzIGEgbGVhZiBub2RlXG4gICAgICAgICAgICBpZiAoIW1hdGNoZXNVc2VkTWV0cmljKG5ld1BhdGgsIHVzZWRNZXRyaWNzKSkge1xuICAgICAgICAgICAgICB1bnVzZWRNZXRyaWNzLnB1c2gobmV3UGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0J3MgYSBicmFuY2g7IHJlY3Vyc2UgaW50byBpdFxuICAgICAgICAgICAgdHJhdmVyc2VUcmVlKG5vZGVba2V5XSwgbmV3UGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBTdGFydCB0cmF2ZXJzaW5nIGZyb20gdGhlIHJvb3Qgb2YgdGhlIG1ldHJpYyB0cmVlXG4gICAgICB0cmF2ZXJzZVRyZWUobWV0cmljVHJlZSwgc2VsZWN0ZWRTZXJ2aWNlLnZhbHVlKTtcblxuICAgICAgY29uc29sZS5sb2coXCJVbnVzZWQgTWV0cmljczpcIiwgdW51c2VkTWV0cmljcyk7XG4gIFxuICAgICAgLy8gU2V0IHRoZSBjb21wYXJpc29uIHJlc3VsdFxuICAgICAgc2V0TWV0cmljQ29tcGFyaXNvbih7XG4gICAgICAgIHVzZWRNZXRyaWNzOiB1c2VkTWV0cmljcyxcbiAgICAgICAgdW51c2VkTWV0cmljczogdW51c2VkTWV0cmljcyxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY29tcGFyaW5nIG1ldHJpY3M6XCIsIGVycm9yKTtcbiAgICB9XG4gIH07XG5cblxuICAvLyBUcmlnZ2VyIGNvbXBhcmlzb24gd2hlbiBib3RoIHNlcnZpY2UgYW5kIGRhc2hib2FyZCBhcmUgc2VsZWN0ZWRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBmZXRjaEFuZENvbXBhcmVNZXRyaWNzID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKHNlbGVjdGVkU2VydmljZSAmJiBzZWxlY3RlZERhc2hib2FyZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFNlcnZpY2VNZXRyaWNzKHNlbGVjdGVkU2VydmljZS5sYWJlbCk7IC8vIEZldGNoIGZvcm1hdHRlZCBtZXRyaWNzXG4gICAgICAgICAgY29uc3QgZm9ybWF0dGVkTWV0cmljcyA9IHJlc3VsdC5mbGF0TGlzdDtcblxuICAgICAgICAgIGNvbnN0IHRyZWVNZXRyaWNzOlJlY29yZDxzdHJpbmcsIGFueT4gPSByZXN1bHQudHJlZVxuICAgICAgICAgIHByaW50VHJlZSh0cmVlTWV0cmljcyk7XG5cbiAgICAgICAgICBhd2FpdCBjb21wYXJlTWV0cmljcyhmb3JtYXR0ZWRNZXRyaWNzLCB0cmVlTWV0cmljcyk7IC8vIENvbXBhcmUgbWV0cmljc1xuXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZmV0Y2hpbmcgb3IgY29tcGFyaW5nIG1ldHJpY3M6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBmZXRjaEFuZENvbXBhcmVNZXRyaWNzKCk7XG4gIH0sIFtzZWxlY3RlZFNlcnZpY2UsIHNlbGVjdGVkRGFzaGJvYXJkXSk7XG5cbiAgY29uc3QgcmVtb3ZlUmVkdW5kYW50U3VmZml4ZXMgPSAobWV0cmljczogc3RyaW5nW10pOiBzdHJpbmdbXSA9PiB7XG4gICAgLy8gcmVtb3ZlcyByZWR1bmRhbnQgc3VmZml4ZXMgZnJvbSBtZXRyaWMgbmFtZXNcbiAgICBjb25zdCBncm91cGVkTWV0cmljcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gICAgbWV0cmljcy5mb3JFYWNoKChsYWJlbCkgPT4ge1xuICAgICAgZm9yIChsZXQgc3VmZml4IG9mIHN1ZmZpeFNldCkge1xuICAgICAgICBpZiAobGFiZWwuZW5kc1dpdGgoc3VmZml4KSkge1xuICAgICAgICAgIGNvbnN0IHByZWZpeCA9IGxhYmVsLnNsaWNlKDAsIGxhYmVsLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpO1xuICAgICAgICAgIGlmICghZ3JvdXBlZE1ldHJpY3MuaGFzKHByZWZpeCkpIHtcbiAgICAgICAgICAgIGdyb3VwZWRNZXRyaWNzLmFkZChwcmVmaXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhazsgLy8gT25seSBtYXRjaCBvbmUgc3VmZml4XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEJ1aWxkIG5ldyBPcHRpb24gb2JqZWN0cyB3aXRoIGZvcm1hdHRlZCBsYWJlbHNcbiAgICBjb25zdCBmb3JtYXR0ZWRNZXRyaWNzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGdyb3VwZWRNZXRyaWNzLmZvckVhY2goKHByZWZpeCkgPT4ge1xuICAgICAgZm9ybWF0dGVkTWV0cmljcy5wdXNoKHByZWZpeCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvcm1hdHRlZE1ldHJpY3M7XG4gIH07XG4gIC8vIHRha2UgaW4gYSBmbGF0IGxpc3Qgb2YgbWV0cmljcyBhbmQgZm9ybWF0IHRoZW0gYXMgYSB0cmVlIHN0cnVjdHVyZVxuICBjb25zdCBmb3JtYXRBc1RyZWUgPSAobWV0cmljczogc3RyaW5nW10pOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0+IHtcbiAgICBjb25zdCB0cmVlOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307XG4gIFxuICAgIG1ldHJpY3MuZm9yRWFjaCgobWV0cmljKSA9PiB7XG4gICAgICBjb25zdCBwYXJ0cyA9IG1ldHJpYy5zcGxpdCgnLicpO1xuICAgICAgbGV0IGN1cnJlbnRMZXZlbCA9IHRyZWU7XG4gIFxuICAgICAgcGFydHMuZm9yRWFjaCgocGFydCwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKCFjdXJyZW50TGV2ZWxbcGFydF0pIHtcbiAgICAgICAgICBjdXJyZW50TGV2ZWxbcGFydF0gPSBpbmRleCA9PT0gcGFydHMubGVuZ3RoIC0gMSA/IG51bGwgOiB7fTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50TGV2ZWwgPSBjdXJyZW50TGV2ZWxbcGFydF07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgXG4gICAgcmV0dXJuIHRyZWU7XG4gIH07XG4gIFxuXG4gIC8vIFRyZWUgTm9kZSBDb21wb25lbnQgaW4gUmVhY3QgKGZvciByZW5kZXJpbmcgZXhwYW5kYWJsZSBsaXN0cylcbiAgY29uc3QgVHJlZU5vZGUgPSAoeyBsYWJlbCwgY2hpbGRyZW4gfTogeyBsYWJlbDogc3RyaW5nOyBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZSB9KSA9PiB7XG4gICAgY29uc3QgW2lzRXhwYW5kZWQsIHNldElzRXhwYW5kZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBcbiAgICBjb25zdCB0b2dnbGVFeHBhbnNpb24gPSAoKSA9PiB7XG4gICAgICBzZXRJc0V4cGFuZGVkKCFpc0V4cGFuZGVkKTtcbiAgICB9O1xuICBcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBzdHlsZT17eyBtYXJnaW5MZWZ0OiAnMjBweCcgfX0+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBvbkNsaWNrPXt0b2dnbGVFeHBhbnNpb259XG4gICAgICAgICAgc3R5bGU9e3sgY3Vyc29yOiAncG9pbnRlcicsIGZvbnRXZWlnaHQ6IGNoaWxkcmVuID8gJ2JvbGQnIDogJ25vcm1hbCcgfX1cbiAgICAgICAgPlxuICAgICAgICAgIHtjaGlsZHJlbiA/IChpc0V4cGFuZGVkID8gPFZzY0NoZXZyb25SaWdodCAvPiA6IDxWc2NDaGV2cm9uRG93biAvPikgOiA8VnNjSW5kZW50IC8+fSB7bGFiZWx9XG4gICAgICAgIDwvZGl2PlxuICAgICAgICB7aXNFeHBhbmRlZCAmJiBjaGlsZHJlbiAmJiA8ZGl2PntjaGlsZHJlbn08L2Rpdj59XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9O1xuICBjb25zdCBUcmVlID0gKHsgZGF0YSB9OiB7IGRhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4gfSkgPT4ge1xuICAgIGNvbnN0IHJlbmRlclRyZWUgPSAobm9kZTogUmVjb3JkPHN0cmluZywgYW55Pik6IFJlYWN0LlJlYWN0Tm9kZSA9PiB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMobm9kZSkubWFwKChrZXkpID0+IChcbiAgICAgICAgPFRyZWVOb2RlIGtleT17a2V5fSBsYWJlbD17a2V5fT5cbiAgICAgICAgICB7bm9kZVtrZXldICE9PSBudWxsICYmIHR5cGVvZiBub2RlW2tleV0gPT09ICdvYmplY3QnID8gcmVuZGVyVHJlZShub2RlW2tleV0pIDogbnVsbH1cbiAgICAgICAgPC9UcmVlTm9kZT5cbiAgICAgICkpO1xuICAgIH07XG4gIFxuICAgIHJldHVybiA8ZGl2PntyZW5kZXJUcmVlKGRhdGEpfTwvZGl2PjtcbiAgfTtcbiAgXG4gIFxuICBcblxuICBcblxuICByZXR1cm4gKFxuICAgIDxQbHVnaW5QYWdlPlxuICAgICAgPGRpdiBkYXRhLXRlc3RpZD17dGVzdElkcy5wYWdlT25lLmNvbnRhaW5lcn0+XG5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5tYXJnaW5Ub3B9PlxuICAgICAgICAgIDxTZWxlY3RcbiAgICAgICAgICAgIG9wdGlvbnM9e2F2YWlsYWJsZVNlcnZpY2VzfVxuICAgICAgICAgICAgdmFsdWU9e3NlbGVjdGVkU2VydmljZX1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXtzZXRTZWxlY3RlZFNlcnZpY2V9XG4gICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlNlbGVjdCBTZXJ2aWNlXCJcbiAgICAgICAgICAgIGlzTG9hZGluZz17bG9hZGluZ1NlcnZpY2VzfVxuICAgICAgICAgIC8+XG4gICAgICAgICAge3NlcnZpY2VFcnJvciAmJiA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmVycm9yfT57c2VydmljZUVycm9yfTwvZGl2Pn1cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5tYXJnaW5Ub3B9PlxuICAgICAgICAgIDxTZWxlY3RcbiAgICAgICAgICAgIG9wdGlvbnM9e2F2YWlsYWJsZURhc2hib2FyZHN9XG4gICAgICAgICAgICB2YWx1ZT17c2VsZWN0ZWREYXNoYm9hcmR9XG4gICAgICAgICAgICBvbkNoYW5nZT17c2V0U2VsZWN0ZWREYXNoYm9hcmR9XG4gICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlNlbGVjdCBEYXNoYm9hcmRcIlxuICAgICAgICAgICAgaXNMb2FkaW5nPXtsb2FkaW5nRGFzaGJvYXJkc31cbiAgICAgICAgICAvPlxuICAgICAgICAgIHtkYXNoYm9hcmRFcnJvciAmJiA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmVycm9yfT57ZGFzaGJvYXJkRXJyb3J9PC9kaXY+fVxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICB7bWV0cmljQ29tcGFyaXNvbiAmJiAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5tYXJnaW5Ub3B9PlxuICAgICAgICAgICAgPGg0Pk1ldHJpYyBDb21wYXJpc29uOjwvaDQ+XG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICA8c3Ryb25nPlVzZWQgTWV0cmljczo8L3N0cm9uZz5cbiAgICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgIHsvKiB7bWV0cmljQ29tcGFyaXNvbi51c2VkTWV0cmljcy5tYXAoKG1ldHJpYykgPT4gKFxuICAgICAgICAgICAgICAgICAgPGxpIGtleT17bWV0cmljfT57bWV0cmljfTwvbGk+XG4gICAgICAgICAgICAgICAgKSl9ICovfVxuICAgICAgICAgICAgICAgIHttZXRyaWNDb21wYXJpc29uLnVzZWRNZXRyaWNzICYmIG1ldHJpY0NvbXBhcmlzb24udXNlZE1ldHJpY3MubGVuZ3RoID4gMCA/IChcbiAgICAgICAgICAgICAgICAgIDxUcmVlIGRhdGE9e2Zvcm1hdEFzVHJlZShtZXRyaWNDb21wYXJpc29uLnVzZWRNZXRyaWNzKX0gLz5cbiAgICAgICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgICAgPHA+Tm8gdXNlZCBtZXRyaWNzLjwvcD5cbiAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICA8c3Ryb25nPlVudXNlZCBNZXRyaWNzOjwvc3Ryb25nPlxuICAgICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgey8qIHttZXRyaWNDb21wYXJpc29uLnVudXNlZE1ldHJpY3MubWFwKChtZXRyaWMpID0+IChcbiAgICAgICAgICAgICAgICAgIDxsaSBrZXk9e21ldHJpY30+e21ldHJpY308L2xpPlxuICAgICAgICAgICAgICAgICkpfSAqL31cbiAgICAgICAgICAgICAgICB7bWV0cmljQ29tcGFyaXNvbi51bnVzZWRNZXRyaWNzICYmIG1ldHJpY0NvbXBhcmlzb24udW51c2VkTWV0cmljcy5sZW5ndGggPiAwID8gKFxuICAgICAgICAgICAgICAgICAgPFRyZWUgZGF0YT17Zm9ybWF0QXNUcmVlKG1ldHJpY0NvbXBhcmlzb24udW51c2VkTWV0cmljcyl9IC8+XG4gICAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICAgIDxwPk5vIHVudXNlZCBtZXRyaWNzLjwvcD5cbiAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5tYXJnaW5Ub3B9PlxuICAgICAgICAgIDxMaW5rQnV0dG9uIGRhdGEtdGVzdGlkPXt0ZXN0SWRzLnBhZ2VPbmUubmF2aWdhdGVUb0ZvdXJ9IGhyZWY9e3ByZWZpeFJvdXRlKFJPVVRFUy5Gb3VyKX0+XG4gICAgICAgICAgICBGdWxsLXdpZHRoIHBhZ2UgZXhhbXBsZVxuICAgICAgICAgIDwvTGlua0J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L1BsdWdpblBhZ2U+XG4gICk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhZ2VPbmU7XG5cbi8vIFN0eWxlc1xuY29uc3QgZ2V0U3R5bGVzID0gKHRoZW1lOiBHcmFmYW5hVGhlbWUyKSA9PiAoe1xuICBtYXJnaW5Ub3A6IGNzc2BcbiAgICBtYXJnaW4tdG9wOiAke3RoZW1lLnNwYWNpbmcoMil9O1xuICBgLFxuICBlcnJvcjogY3NzYFxuICAgIGNvbG9yOiAke3RoZW1lLmNvbG9ycy5lcnJvci50ZXh0fTtcbiAgICBtYXJnaW4tdG9wOiAke3RoZW1lLnNwYWNpbmcoMSl9O1xuICBgLFxufSk7XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsImNzcyIsIkxpbmtCdXR0b24iLCJ1c2VTdHlsZXMyIiwiU2VsZWN0IiwicHJlZml4Um91dGUiLCJ0ZXN0SWRzIiwiUGx1Z2luUGFnZSIsImdldEJhY2tlbmRTcnYiLCJnZXRTZXJ2aWNlTWV0cmljcyIsInByaW50VHJlZSIsIlJPVVRFUyIsInN1ZmZpeFNldCIsIlZzY0NoZXZyb25Eb3duIiwiVnNjQ2hldnJvblJpZ2h0IiwiVnNjSW5kZW50IiwiUGFnZU9uZSIsInN0eWxlcyIsImdldFN0eWxlcyIsInNlbGVjdGVkU2VydmljZSIsInNldFNlbGVjdGVkU2VydmljZSIsInNlbGVjdGVkRGFzaGJvYXJkIiwic2V0U2VsZWN0ZWREYXNoYm9hcmQiLCJhdmFpbGFibGVTZXJ2aWNlcyIsInNldEF2YWlsYWJsZVNlcnZpY2VzIiwiYXZhaWxhYmxlRGFzaGJvYXJkcyIsInNldEF2YWlsYWJsZURhc2hib2FyZHMiLCJsb2FkaW5nU2VydmljZXMiLCJzZXRMb2FkaW5nU2VydmljZXMiLCJsb2FkaW5nRGFzaGJvYXJkcyIsInNldExvYWRpbmdEYXNoYm9hcmRzIiwic2VydmljZUVycm9yIiwic2V0U2VydmljZUVycm9yIiwiZGFzaGJvYXJkRXJyb3IiLCJzZXREYXNoYm9hcmRFcnJvciIsIm1ldHJpY0NvbXBhcmlzb24iLCJzZXRNZXRyaWNDb21wYXJpc29uIiwiZmV0Y2hBdmFpbGFibGVTZXJ2aWNlcyIsImZldGNoQXZhaWxhYmxlRGFzaGJvYXJkcyIsInJlc3BvbnNlIiwiZmV0Y2giLCJzZXJ2aWNlcyIsImpzb24iLCJmb3JtYXR0ZWRTZXJ2aWNlcyIsIm1hcCIsInNlcnZpY2UiLCJsYWJlbCIsInRleHQiLCJ2YWx1ZSIsImVycm9yIiwiY29uc29sZSIsImRhc2hib2FyZHMiLCJnZXQiLCJmb3JtYXR0ZWREYXNoYm9hcmRzIiwiZGFzaCIsInRpdGxlIiwidWlkIiwiZ2V0VXNlZE1ldHJpY3MiLCJkYXNoYm9hcmQiLCJkYXNoYm9hcmRQYW5lbHMiLCJwYW5lbHMiLCJ1c2VkTWV0cmljc1NldCIsIlNldCIsImZvckVhY2giLCJwYW5lbCIsInRhcmdldHMiLCJBcnJheSIsImlzQXJyYXkiLCJ0YXJnZXQiLCJ0YXJnZXRNZXRyaWMiLCJmdW5jdGlvblJlZ2V4IiwibWF0Y2giLCJzZXJ2aWNlUmVnZXgiLCJSZWdFeHAiLCJ0ZXN0IiwiYWRkIiwidXNlZE1ldHJpY3NBcnJheSIsImZyb20iLCJyZW1vdmVSZWR1bmRhbnRTdWZmaXhlcyIsImxvZyIsImNvbXBhcmVNZXRyaWNzIiwiZm9ybWF0dGVkTWV0cmljcyIsIm1ldHJpY1RyZWUiLCJhdmFpbGFibGVNZXRyaWNzIiwidXNlZE1ldHJpY3MiLCJ1bnVzZWRNZXRyaWNzIiwibWF0Y2hlc1VzZWRNZXRyaWMiLCJtZXRyaWMiLCJzb21lIiwidXNlZE1ldHJpYyIsInJlZ2V4UGF0dGVybiIsInJlcGxhY2UiLCJyZWdleCIsInRyYXZlcnNlVHJlZSIsIm5vZGUiLCJjdXJyZW50UGF0aCIsImtleSIsIm5ld1BhdGgiLCJwdXNoIiwiZmV0Y2hBbmRDb21wYXJlTWV0cmljcyIsInJlc3VsdCIsImZsYXRMaXN0IiwidHJlZU1ldHJpY3MiLCJ0cmVlIiwibWV0cmljcyIsImdyb3VwZWRNZXRyaWNzIiwic3VmZml4IiwiZW5kc1dpdGgiLCJwcmVmaXgiLCJzbGljZSIsImxlbmd0aCIsImhhcyIsImZvcm1hdEFzVHJlZSIsInBhcnRzIiwic3BsaXQiLCJjdXJyZW50TGV2ZWwiLCJwYXJ0IiwiaW5kZXgiLCJUcmVlTm9kZSIsImNoaWxkcmVuIiwiaXNFeHBhbmRlZCIsInNldElzRXhwYW5kZWQiLCJ0b2dnbGVFeHBhbnNpb24iLCJkaXYiLCJzdHlsZSIsIm1hcmdpbkxlZnQiLCJvbkNsaWNrIiwiY3Vyc29yIiwiZm9udFdlaWdodCIsIlRyZWUiLCJkYXRhIiwicmVuZGVyVHJlZSIsIk9iamVjdCIsImtleXMiLCJkYXRhLXRlc3RpZCIsInBhZ2VPbmUiLCJjb250YWluZXIiLCJjbGFzc05hbWUiLCJtYXJnaW5Ub3AiLCJvcHRpb25zIiwib25DaGFuZ2UiLCJwbGFjZWhvbGRlciIsImlzTG9hZGluZyIsImg0Iiwic3Ryb25nIiwidWwiLCJwIiwibmF2aWdhdGVUb0ZvdXIiLCJocmVmIiwiRm91ciIsInRoZW1lIiwic3BhY2luZyIsImNvbG9ycyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/PageOne.tsx\n");

/***/ }),

/***/ "./utils/utils.routing.ts":
/*!********************************!*\
  !*** ./utils/utils.routing.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   prefixRoute: () => (/* binding */ prefixRoute)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants */ \"./constants.ts\");\n\n// Prefixes the route with the base URL of the plugin\nfunction prefixRoute(route) {\n    return `${_constants__WEBPACK_IMPORTED_MODULE_0__.PLUGIN_BASE_URL}/${route}`;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi91dGlscy91dGlscy5yb3V0aW5nLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQStDO0FBRS9DLHFEQUFxRDtBQUM5QyxTQUFTQyxZQUFZQyxLQUFhO0lBQ3ZDLE9BQU8sQ0FBQyxFQUFFRix1REFBZUEsQ0FBQyxDQUFDLEVBQUVFLE1BQU0sQ0FBQztBQUN0QyIsInNvdXJjZXMiOlsid2VicGFjazovL2htY2NsaW5pYy1za2VsZXRvbi1hcHAvLi91dGlscy91dGlscy5yb3V0aW5nLnRzPzRjNzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUExVR0lOX0JBU0VfVVJMIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcblxuLy8gUHJlZml4ZXMgdGhlIHJvdXRlIHdpdGggdGhlIGJhc2UgVVJMIG9mIHRoZSBwbHVnaW5cbmV4cG9ydCBmdW5jdGlvbiBwcmVmaXhSb3V0ZShyb3V0ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGAke1BMVUdJTl9CQVNFX1VSTH0vJHtyb3V0ZX1gO1xufVxuIl0sIm5hbWVzIjpbIlBMVUdJTl9CQVNFX1VSTCIsInByZWZpeFJvdXRlIiwicm91dGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./utils/utils.routing.ts\n");

/***/ })

}]);