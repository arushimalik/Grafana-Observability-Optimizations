"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhmcclinic_skeleton_app"] = self["webpackChunkhmcclinic_skeleton_app"] || []).push([["pages_PageOne_tsx"],{

/***/ "./components/testIds.ts":
/*!*******************************!*\
  !*** ./components/testIds.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   testIds: () => (/* binding */ testIds)\n/* harmony export */ });\nconst testIds = {\n    appConfig: {\n        apiKey: 'data-testid ac-api-key',\n        apiUrl: 'data-testid ac-api-url',\n        submit: 'data-testid ac-submit-form'\n    },\n    pageOne: {\n        container: 'data-testid pg-one-container',\n        navigateToFour: 'data-testid navigate-to-four'\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL3Rlc3RJZHMudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLFVBQVU7SUFDckJDLFdBQVc7UUFDVEMsUUFBUTtRQUNSQyxRQUFRO1FBQ1JDLFFBQVE7SUFDVjtJQUNBQyxTQUFTO1FBQ1BDLFdBQVc7UUFDWEMsZ0JBQWdCO0lBQ2xCO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL2htY2NsaW5pYy1za2VsZXRvbi1hcHAvLi9jb21wb25lbnRzL3Rlc3RJZHMudHM/MDA1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdGVzdElkcyA9IHtcbiAgYXBwQ29uZmlnOiB7XG4gICAgYXBpS2V5OiAnZGF0YS10ZXN0aWQgYWMtYXBpLWtleScsXG4gICAgYXBpVXJsOiAnZGF0YS10ZXN0aWQgYWMtYXBpLXVybCcsXG4gICAgc3VibWl0OiAnZGF0YS10ZXN0aWQgYWMtc3VibWl0LWZvcm0nLFxuICB9LFxuICBwYWdlT25lOiB7XG4gICAgY29udGFpbmVyOiAnZGF0YS10ZXN0aWQgcGctb25lLWNvbnRhaW5lcicsXG4gICAgbmF2aWdhdGVUb0ZvdXI6ICdkYXRhLXRlc3RpZCBuYXZpZ2F0ZS10by1mb3VyJyxcbiAgfSxcbn07XG4iXSwibmFtZXMiOlsidGVzdElkcyIsImFwcENvbmZpZyIsImFwaUtleSIsImFwaVVybCIsInN1Ym1pdCIsInBhZ2VPbmUiLCJjb250YWluZXIiLCJuYXZpZ2F0ZVRvRm91ciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/testIds.ts\n");

/***/ }),

/***/ "./getServiceMetrics.tsx":
/*!*******************************!*\
  !*** ./getServiceMetrics.tsx ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getServiceMetrics: () => (/* binding */ getServiceMetrics),\n/* harmony export */   printTree: () => (/* binding */ printTree)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./constants.ts\");\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _async_to_generator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\n\nfunction getServiceMetrics(selectedService) {\n    return _getServiceMetrics.apply(this, arguments);\n}\nfunction _getServiceMetrics() {\n    _getServiceMetrics = _async_to_generator(function*(selectedService) {\n        // This function will take in a selected service as a string and return \n        // a list of all metrics (the leaves of the service metrics tree) and a tree structure for the whole metrics tree\n        try {\n            console.log(`Selected service: ${selectedService}`);\n            const response = yield fetch(`http://localhost:9080/metrics/find?query=${selectedService}.*`);\n            const services = yield response.json();\n            const flatList = [];\n            const tree = {};\n            // Function to build the tree and collect leaf metrics into the flat list\n            const buildTree = /*#__PURE__*/ function() {\n                var _ref = _async_to_generator(function*(service, treeNode) {\n                    if (service.leaf) {\n                        // Add leaf to flatList and tree\n                        if (!_constants__WEBPACK_IMPORTED_MODULE_0__.suffixSet.has(`.${service.text}`)) {\n                            // if the leaf text is not in the suffix set:\n                            flatList.push(service.id);\n                            treeNode[service.text] = null; // Leaf nodes in the tree are null\n                        }\n                    } else {\n                        // Create a new branch in the tree\n                        treeNode[service.text] = {};\n                        // Fetch children\n                        const childResponse = yield fetch(`http://localhost:9080/metrics/find?query=${service.id}.*`);\n                        const children = yield childResponse.json();\n                        if (children.length === 0) {\n                            // If no children, treat as a leaf\n                            flatList.push(service.id);\n                            treeNode[service.text] = null;\n                        } else {\n                            // Recursively process children\n                            yield Promise.all(children.map((child)=>buildTree(child, treeNode[service.text])));\n                            if (Object.keys(treeNode[service.text]).length === 0) {\n                                // check to see after we process all the children if any children remain. \n                                // if no children remain, this node is a leaf so treat it as one.\n                                treeNode[service.text] = null;\n                                flatList.push(service.id);\n                            }\n                        }\n                    }\n                });\n                return function buildTree(service, treeNode) {\n                    return _ref.apply(this, arguments);\n                };\n            }();\n            console.log(flatList);\n            // Build the tree and flat list by processing each root service\n            yield Promise.all(services.map((service)=>buildTree(service, tree)));\n            console.log(\"Flat List:\", flatList);\n            console.log(\"Tree Structure:\", tree);\n            return {\n                flatList,\n                tree\n            };\n        } catch (error) {\n            console.error(`Error fetching metrics for ${selectedService} from Graphite:`, error);\n            return {\n                flatList: [],\n                tree: {}\n            };\n        }\n    });\n    return _getServiceMetrics.apply(this, arguments);\n}\nfunction printTree(tree, indent = 0) {\n    const indentation = \"  \".repeat(indent); // Create indentation based on the depth of the node\n    for (const [key, value] of Object.entries(tree)){\n        if (value === null) {\n            // If it's a leaf node\n            console.log(`${indentation}- ${key}`);\n        } else {\n            // If it's a branch\n            console.log(`${indentation}+ ${key}`);\n            printTree(value, indent + 1); // Recurse into the branch\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QzdGLEtBQUssTUFBTSxDQUFDRyxLQUFLQyxNQUFNLElBQUlSLE9BQU9TLE9BQU8sQ0FBQ3pCLE1BQU87UUFDL0MsSUFBSXdCLFVBQVUsTUFBTTtZQUNsQixzQkFBc0I7WUFDdEIvQixRQUFRQyxHQUFHLENBQUMsQ0FBQyxFQUFFMkIsWUFBWSxFQUFFLEVBQUVFLElBQUksQ0FBQztRQUN0QyxPQUFPO1lBQ0wsbUJBQW1CO1lBQ25COUIsUUFBUUMsR0FBRyxDQUFDLENBQUMsRUFBRTJCLFlBQVksRUFBRSxFQUFFRSxJQUFJLENBQUM7WUFDcENKLFVBQVVLLE9BQU9KLFNBQVMsSUFBSSwwQkFBMEI7UUFDMUQ7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG1jY2xpbmljLXNrZWxldG9uLWFwcC8uL2dldFNlcnZpY2VNZXRyaWNzLnRzeD8yMjQ0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNlcnZpY2VSZXNwb25zZSwgc3VmZml4U2V0IH0gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U2VydmljZU1ldHJpY3Moc2VsZWN0ZWRTZXJ2aWNlOiBzdHJpbmcpOiBQcm9taXNlPHsgZmxhdExpc3Q6IHN0cmluZ1tdOyB0cmVlOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IH0+IHtcbiAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIHRha2UgaW4gYSBzZWxlY3RlZCBzZXJ2aWNlIGFzIGEgc3RyaW5nIGFuZCByZXR1cm4gXG4gIC8vIGEgbGlzdCBvZiBhbGwgbWV0cmljcyAodGhlIGxlYXZlcyBvZiB0aGUgc2VydmljZSBtZXRyaWNzIHRyZWUpIGFuZCBhIHRyZWUgc3RydWN0dXJlIGZvciB0aGUgd2hvbGUgbWV0cmljcyB0cmVlXG5cbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhgU2VsZWN0ZWQgc2VydmljZTogJHtzZWxlY3RlZFNlcnZpY2V9YCk7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGBodHRwOi8vbG9jYWxob3N0OjkwODAvbWV0cmljcy9maW5kP3F1ZXJ5PSR7c2VsZWN0ZWRTZXJ2aWNlfS4qYCk7XG4gICAgY29uc3Qgc2VydmljZXM6IFNlcnZpY2VSZXNwb25zZVtdID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgY29uc3QgZmxhdExpc3Q6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgdHJlZTogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9O1xuXG4gICAgLy8gRnVuY3Rpb24gdG8gYnVpbGQgdGhlIHRyZWUgYW5kIGNvbGxlY3QgbGVhZiBtZXRyaWNzIGludG8gdGhlIGZsYXQgbGlzdFxuICAgIGNvbnN0IGJ1aWxkVHJlZSA9IGFzeW5jIChzZXJ2aWNlOiBTZXJ2aWNlUmVzcG9uc2UsIHRyZWVOb2RlOiBhbnkpID0+IHtcbiAgICAgIGlmIChzZXJ2aWNlLmxlYWYpIHtcbiAgICAgICAgLy8gQWRkIGxlYWYgdG8gZmxhdExpc3QgYW5kIHRyZWVcbiAgICAgICAgaWYgKCFzdWZmaXhTZXQuaGFzKGAuJHtzZXJ2aWNlLnRleHR9YCkpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgbGVhZiB0ZXh0IGlzIG5vdCBpbiB0aGUgc3VmZml4IHNldDpcbiAgICAgICAgICBmbGF0TGlzdC5wdXNoKHNlcnZpY2UuaWQpO1xuICAgICAgICAgIHRyZWVOb2RlW3NlcnZpY2UudGV4dF0gPSBudWxsOyAvLyBMZWFmIG5vZGVzIGluIHRoZSB0cmVlIGFyZSBudWxsXG4gICAgICAgIH0gXG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBicmFuY2ggaW4gdGhlIHRyZWVcbiAgICAgICAgdHJlZU5vZGVbc2VydmljZS50ZXh0XSA9IHt9O1xuXG4gICAgICAgIC8vIEZldGNoIGNoaWxkcmVuXG4gICAgICAgIGNvbnN0IGNoaWxkUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgaHR0cDovL2xvY2FsaG9zdDo5MDgwL21ldHJpY3MvZmluZD9xdWVyeT0ke3NlcnZpY2UuaWR9LipgKTtcbiAgICAgICAgY29uc3QgY2hpbGRyZW46IFNlcnZpY2VSZXNwb25zZVtdID0gYXdhaXQgY2hpbGRSZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIC8vIElmIG5vIGNoaWxkcmVuLCB0cmVhdCBhcyBhIGxlYWZcbiAgICAgICAgICBmbGF0TGlzdC5wdXNoKHNlcnZpY2UuaWQpO1xuICAgICAgICAgIHRyZWVOb2RlW3NlcnZpY2UudGV4dF0gPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHByb2Nlc3MgY2hpbGRyZW5cbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChjaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiBidWlsZFRyZWUoY2hpbGQsIHRyZWVOb2RlW3NlcnZpY2UudGV4dF0pKSk7XG5cbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXModHJlZU5vZGVbc2VydmljZS50ZXh0XSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBjaGVjayB0byBzZWUgYWZ0ZXIgd2UgcHJvY2VzcyBhbGwgdGhlIGNoaWxkcmVuIGlmIGFueSBjaGlsZHJlbiByZW1haW4uIFxuICAgICAgICAgICAgLy8gaWYgbm8gY2hpbGRyZW4gcmVtYWluLCB0aGlzIG5vZGUgaXMgYSBsZWFmIHNvIHRyZWF0IGl0IGFzIG9uZS5cbiAgICAgICAgICAgIHRyZWVOb2RlW3NlcnZpY2UudGV4dF0gPSBudWxsO1xuICAgICAgICAgICAgZmxhdExpc3QucHVzaChzZXJ2aWNlLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnNvbGUubG9nKGZsYXRMaXN0KTtcbiAgICAvLyBCdWlsZCB0aGUgdHJlZSBhbmQgZmxhdCBsaXN0IGJ5IHByb2Nlc3NpbmcgZWFjaCByb290IHNlcnZpY2VcbiAgICBhd2FpdCBQcm9taXNlLmFsbChzZXJ2aWNlcy5tYXAoKHNlcnZpY2UpID0+IGJ1aWxkVHJlZShzZXJ2aWNlLCB0cmVlKSkpO1xuXG4gICAgY29uc29sZS5sb2coXCJGbGF0IExpc3Q6XCIsIGZsYXRMaXN0KTtcbiAgICBjb25zb2xlLmxvZyhcIlRyZWUgU3RydWN0dXJlOlwiLCB0cmVlKTtcblxuICAgIHJldHVybiB7IGZsYXRMaXN0LCB0cmVlIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgbWV0cmljcyBmb3IgJHtzZWxlY3RlZFNlcnZpY2V9IGZyb20gR3JhcGhpdGU6YCwgZXJyb3IpO1xuICAgIHJldHVybiB7IGZsYXRMaXN0OiBbXSwgdHJlZToge30gfTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJpbnRUcmVlICh0cmVlOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBpbmRlbnQgPSAwKTogdm9pZCB7XG4gIGNvbnN0IGluZGVudGF0aW9uID0gXCIgIFwiLnJlcGVhdChpbmRlbnQpOyAvLyBDcmVhdGUgaW5kZW50YXRpb24gYmFzZWQgb24gdGhlIGRlcHRoIG9mIHRoZSBub2RlXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHRyZWUpKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAvLyBJZiBpdCdzIGEgbGVhZiBub2RlXG4gICAgICBjb25zb2xlLmxvZyhgJHtpbmRlbnRhdGlvbn0tICR7a2V5fWApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBpdCdzIGEgYnJhbmNoXG4gICAgICBjb25zb2xlLmxvZyhgJHtpbmRlbnRhdGlvbn0rICR7a2V5fWApO1xuICAgICAgcHJpbnRUcmVlKHZhbHVlLCBpbmRlbnQgKyAxKTsgLy8gUmVjdXJzZSBpbnRvIHRoZSBicmFuY2hcbiAgICB9XG4gIH1cbn07XG4iXSwibmFtZXMiOlsic3VmZml4U2V0IiwiZ2V0U2VydmljZU1ldHJpY3MiLCJzZWxlY3RlZFNlcnZpY2UiLCJjb25zb2xlIiwibG9nIiwicmVzcG9uc2UiLCJmZXRjaCIsInNlcnZpY2VzIiwianNvbiIsImZsYXRMaXN0IiwidHJlZSIsImJ1aWxkVHJlZSIsInNlcnZpY2UiLCJ0cmVlTm9kZSIsImxlYWYiLCJoYXMiLCJ0ZXh0IiwicHVzaCIsImlkIiwiY2hpbGRSZXNwb25zZSIsImNoaWxkcmVuIiwibGVuZ3RoIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsImNoaWxkIiwiT2JqZWN0Iiwia2V5cyIsImVycm9yIiwicHJpbnRUcmVlIiwiaW5kZW50IiwiaW5kZW50YXRpb24iLCJyZXBlYXQiLCJrZXkiLCJ2YWx1ZSIsImVudHJpZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./getServiceMetrics.tsx\n");

/***/ }),

/***/ "./pages/PageOne.tsx":
/*!***************************!*\
  !*** ./pages/PageOne.tsx ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @emotion/css */ \"@emotion/css\");\n/* harmony import */ var _emotion_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_emotion_css__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @grafana/ui */ \"@grafana/ui\");\n/* harmony import */ var _grafana_ui__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _components_testIds__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/testIds */ \"./components/testIds.ts\");\n/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @grafana/runtime */ \"@grafana/runtime\");\n/* harmony import */ var _grafana_runtime__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_grafana_runtime__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _getServiceMetrics__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../getServiceMetrics */ \"./getServiceMetrics.tsx\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../constants */ \"./constants.ts\");\n/* harmony import */ var react_icons_vsc__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react-icons/vsc */ \"../node_modules/react-icons/vsc/index.mjs\");\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _async_to_generator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\n\n\n\n\n\n\n\n\nfunction PageOne() {\n    const styles = (0,_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.useStyles2)(getStyles);\n    // State for selected options and available options\n    const [selectedService, setSelectedService] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [selectedDashboard, setSelectedDashboard] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [availableServices, setAvailableServices] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [availableDashboards, setAvailableDashboards] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loadingServices, setLoadingServices] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [loadingDashboards, setLoadingDashboards] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [serviceError, setServiceError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [dashboardError, setDashboardError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [metricComparison, setMetricComparison] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        fetchAvailableServices();\n        fetchAvailableDashboards();\n    }, []);\n    const fetchAvailableServices = /*#__PURE__*/ function() {\n        var _ref = _async_to_generator(function*() {\n            setLoadingServices(true);\n            setServiceError(null);\n            try {\n                const response = yield fetch('http://localhost:9080/metrics/find?query=*'); // TODO: THIS SHOULD NOT BE HARDCODED. FIX THIS.\n                const services = yield response.json();\n                const formattedServices = services.map((service)=>({\n                        label: service.text,\n                        value: service.text\n                    }));\n                setAvailableServices(formattedServices);\n            } catch (error) {\n                console.error('Error fetching services from Graphite:', error);\n                setServiceError('Failed to load services');\n            } finally{\n                setLoadingServices(false);\n            }\n        });\n        return function fetchAvailableServices() {\n            return _ref.apply(this, arguments);\n        };\n    }();\n    const fetchAvailableDashboards = /*#__PURE__*/ function() {\n        var _ref = _async_to_generator(function*() {\n            setLoadingDashboards(true);\n            setDashboardError(null);\n            try {\n                const dashboards = yield (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_4__.getBackendSrv)().get('/api/search');\n                const formattedDashboards = dashboards.map((dash)=>({\n                        label: dash.title,\n                        value: dash.uid\n                    }));\n                setAvailableDashboards(formattedDashboards);\n            } catch (error) {\n                console.error('Error fetching dashboards:', error);\n                setDashboardError('Failed to load dashboards');\n            } finally{\n                setLoadingDashboards(false);\n            }\n        });\n        return function fetchAvailableDashboards() {\n            return _ref.apply(this, arguments);\n        };\n    }();\n    function getUsedMetrics() {\n        return _getUsedMetrics.apply(this, arguments);\n    }\n    function _getUsedMetrics() {\n        _getUsedMetrics = _async_to_generator(function*() {\n            if (!selectedService || !selectedDashboard) {\n                console.error(\"Required selections or formatted metrics are missing.\");\n                return;\n            }\n            // Fetch the selected dashboard data to get metrics\n            const dashboard = yield (0,_grafana_runtime__WEBPACK_IMPORTED_MODULE_4__.getBackendSrv)().get(`/api/dashboards/uid/${selectedDashboard.value}`);\n            const dashboardPanels = dashboard.dashboard.panels || [];\n            let usedMetricsSet = new Set();\n            dashboardPanels.forEach((panel)=>{\n                if (panel.targets && Array.isArray(panel.targets)) {\n                    panel.targets.forEach((target)=>{\n                        if (target.target) {\n                            let targetMetric = target.target;\n                            // Regular expression to match any function at the start, followed by a metric name\n                            const functionRegex = /^[a-zA-Z0-9_]+\\((.*?)\\)$/;\n                            // If the target metric starts with a function, remove it and retain the metric name\n                            const match = targetMetric.match(functionRegex);\n                            if (match) {\n                                // Extract the part inside the parentheses (the actual metric name)\n                                targetMetric = match[1];\n                            }\n                            // Use regex to check if the target metric belongs to the selected service\n                            const serviceRegex = new RegExp(`(^|[^a-zA-Z0-9_])${selectedService.value}([^a-zA-Z0-9_]|$)`);\n                            if (serviceRegex.test(targetMetric)) {\n                                usedMetricsSet.add(targetMetric); // Add the metric without the function wrapper\n                            }\n                        }\n                    });\n                }\n            });\n            // Compare available metrics with the used metrics\n            let usedMetricsArray = Array.from(usedMetricsSet);\n            usedMetricsArray = removeRedundantSuffixes(usedMetricsArray);\n            console.log(`used Metrics Array ${usedMetricsArray}`);\n            return usedMetricsArray;\n        });\n        return _getUsedMetrics.apply(this, arguments);\n    }\n    function compareMetrics(formattedMetrics, metricTree) {\n        return _compareMetrics.apply(this, arguments);\n    }\n    function _compareMetrics() {\n        _compareMetrics = _async_to_generator(function*(formattedMetrics, metricTree) {\n            if (!selectedService || !selectedDashboard || !formattedMetrics) {\n                console.error(\"Required selections or formatted metrics are missing.\");\n                return;\n            }\n            try {\n                // Fetch available metrics\n                const availableMetrics = formattedMetrics;\n                console.log(\"Available Metrics:\", availableMetrics);\n                // Fetch used metrics\n                let usedMetrics = yield getUsedMetrics();\n                if (!usedMetrics) {\n                    usedMetrics = [];\n                }\n                console.log(`Used Metrics ${usedMetrics}`);\n                let unusedMetrics = new Array();\n                // Helper function to check if a metric matches any of the used metrics (with wildcard support)\n                const matchesUsedMetric = (metric, usedMetrics)=>{\n                    return usedMetrics.some((usedMetric)=>{\n                        try {\n                            const regexPattern = `^${usedMetric.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*')}$`;\n                            const regex = new RegExp(regexPattern);\n                            console.log(`Tested regex pattern ${regexPattern} on ${metric}, ${regex.test(metric)}`);\n                            return regex.test(metric);\n                        } catch (error) {\n                            console.error(\"Invalid regex in used metric:\", usedMetric, error);\n                            return false;\n                        }\n                    });\n                };\n                // Recursive function to traverse the metric tree\n                const traverseTree = (node, currentPath)=>{\n                    for(const key in node){\n                        const newPath = currentPath ? `${currentPath}.${key}` : key;\n                        if (node[key] === null) {\n                            // It's a leaf node\n                            if (!matchesUsedMetric(newPath, usedMetrics)) {\n                                unusedMetrics.push(newPath);\n                            }\n                        } else {\n                            // It's a branch; recurse into it\n                            traverseTree(node[key], newPath);\n                        }\n                    }\n                };\n                // Start traversing from the root of the metric tree\n                traverseTree(metricTree, selectedService.value);\n                console.log(\"Unused Metrics:\", unusedMetrics);\n                // Set the comparison result\n                setMetricComparison({\n                    usedMetrics: usedMetrics,\n                    unusedMetrics: unusedMetrics\n                });\n            } catch (error) {\n                console.error(\"Error comparing metrics:\", error);\n            }\n        });\n        return _compareMetrics.apply(this, arguments);\n    }\n    ;\n    // Trigger comparison when both service and dashboard are selected\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const fetchAndCompareMetrics = /*#__PURE__*/ function() {\n            var _ref = _async_to_generator(function*() {\n                if (selectedService && selectedDashboard) {\n                    try {\n                        const result = yield (0,_getServiceMetrics__WEBPACK_IMPORTED_MODULE_5__.getServiceMetrics)(selectedService.label); // Fetch formatted metrics\n                        const formattedMetrics = result.flatList;\n                        const treeMetrics = result.tree;\n                        (0,_getServiceMetrics__WEBPACK_IMPORTED_MODULE_5__.printTree)(treeMetrics);\n                        yield compareMetrics(formattedMetrics, treeMetrics); // Compare metrics\n                    } catch (error) {\n                        console.error('Error in fetching or comparing metrics:', error);\n                    }\n                }\n            });\n            return function fetchAndCompareMetrics() {\n                return _ref.apply(this, arguments);\n            };\n        }();\n        fetchAndCompareMetrics();\n    }, [\n        selectedService,\n        selectedDashboard\n    ]);\n    const removeRedundantSuffixes = (metrics)=>{\n        // removes redundant suffixes from metric names\n        const groupedMetrics = new Set();\n        metrics.forEach((label)=>{\n            for (let suffix of _constants__WEBPACK_IMPORTED_MODULE_6__.suffixSet){\n                if (label.endsWith(suffix)) {\n                    const prefix = label.slice(0, label.length - suffix.length);\n                    if (!groupedMetrics.has(prefix)) {\n                        groupedMetrics.add(prefix);\n                    }\n                    break; // Only match one suffix\n                }\n            }\n        });\n        // Build new Option objects with formatted labels\n        const formattedMetrics = [];\n        groupedMetrics.forEach((prefix)=>{\n            formattedMetrics.push(prefix);\n        });\n        return formattedMetrics;\n    };\n    // take in a flat list of metrics and format them as a tree structure\n    const formatAsTree = (metrics)=>{\n        const tree = {};\n        metrics.forEach((metric)=>{\n            const parts = metric.split('.');\n            let currentLevel = tree;\n            parts.forEach((part, index)=>{\n                if (!currentLevel[part]) {\n                    currentLevel[part] = index === parts.length - 1 ? null : {};\n                }\n                currentLevel = currentLevel[part];\n            });\n        });\n        return tree;\n    };\n    // Tree Node Component in React (for rendering expandable lists)\n    const TreeNode = ({ label, children })=>{\n        const [isExpanded, setIsExpanded] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n        const toggleExpansion = ()=>{\n            setIsExpanded(!isExpanded);\n        };\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            style: {\n                marginLeft: '20px'\n            }\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            onClick: toggleExpansion,\n            style: {\n                cursor: 'pointer',\n                fontWeight: children ? 'bold' : 'normal'\n            }\n        }, children ? isExpanded ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_icons_vsc__WEBPACK_IMPORTED_MODULE_7__.VscChevronDown, null) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_icons_vsc__WEBPACK_IMPORTED_MODULE_7__.VscChevronRight, null) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_icons_vsc__WEBPACK_IMPORTED_MODULE_7__.VscIndent, null), \" \", label), isExpanded && children && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", null, children));\n    };\n    const Tree = ({ data })=>{\n        const renderTree = (node)=>{\n            return Object.keys(node).map((key)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(TreeNode, {\n                    key: key,\n                    label: key\n                }, node[key] !== null && typeof node[key] === 'object' ? renderTree(node[key]) : null));\n        };\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", null, renderTree(data));\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_runtime__WEBPACK_IMPORTED_MODULE_4__.PluginPage, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        \"data-testid\": _components_testIds__WEBPACK_IMPORTED_MODULE_3__.testIds.pageOne.container\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        className: styles.marginTop\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Select, {\n        options: availableServices,\n        value: selectedService,\n        onChange: setSelectedService,\n        placeholder: \"Select Service\",\n        isLoading: loadingServices\n    }), serviceError && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        className: styles.error\n    }, serviceError)), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        className: styles.marginTop\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_grafana_ui__WEBPACK_IMPORTED_MODULE_2__.Select, {\n        options: availableDashboards,\n        value: selectedDashboard,\n        onChange: setSelectedDashboard,\n        placeholder: \"Select Dashboard\",\n        isLoading: loadingDashboards\n    }), dashboardError && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        className: styles.error\n    }, dashboardError)), metricComparison && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        className: `${styles.metricComparison} ${styles.responsive}`\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        className: styles.metricsColumn\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"h4\", null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"strong\", null, \"Used Metrics:\")), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"p\", null, metricComparison.usedMetrics.length, \" metrics\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"ul\", null, metricComparison.usedMetrics && metricComparison.usedMetrics.length > 0 ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Tree, {\n        data: formatAsTree(metricComparison.usedMetrics)\n    }) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"p\", null, \"No used metrics.\"))), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        className: styles.metricsColumn\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"h4\", null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"strong\", null, \"Unused Metrics:\")), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"p\", null, metricComparison.unusedMetrics.length, \" metrics\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"ul\", null, metricComparison.unusedMetrics && metricComparison.unusedMetrics.length > 0 ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Tree, {\n        data: formatAsTree(metricComparison.unusedMetrics)\n    }) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"p\", null, \"No unused metrics.\"))))));\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PageOne);\n// Styles\nconst getStyles = (theme)=>({\n        marginTop: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_1__.css)`\n    margin-top: ${theme.spacing(2)};\n  `,\n        error: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_1__.css)`\n    color: ${theme.colors.error.text};\n    margin-top: ${theme.spacing(1)};\n  `,\n        metricComparison: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_1__.css)`\n    margin-top: ${theme.spacing(1)};\n    display: flex;\n    gap: ${theme.spacing(4)};\n    align-items: flex-start;\n    justify-content: space-between;\n  `,\n        metricsColumn: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_1__.css)`\n    margin-top: ${theme.spacing(1)};\n    flex: 1;\n    min-width: 200px;\n  `,\n        responsive: (0,_emotion_css__WEBPACK_IMPORTED_MODULE_1__.css)`\n    @media (max-width: 768px) {\n      flex-direction: column;\n    }\n  `\n    });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxPQUFPLENBQUMsR0FBRzs7O0VBRzFCLENBQUM7UUFDRE4sZUFBZTVJLGlEQUFHLENBQUM7Z0JBQ0wsRUFBRWlKLE1BQU1DLE9BQU8sQ0FBQyxHQUFHOzs7RUFHakMsQ0FBQztRQUNEUCxZQUFZM0ksaURBQUcsQ0FBQzs7OztFQUloQixDQUFDO0lBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9obWNjbGluaWMtc2tlbGV0b24tYXBwLy4vcGFnZXMvUGFnZU9uZS50c3g/MmZmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNzcyB9IGZyb20gJ0BlbW90aW9uL2Nzcyc7XG5pbXBvcnQgeyBHcmFmYW5hVGhlbWUyIH0gZnJvbSAnQGdyYWZhbmEvZGF0YSc7XG5pbXBvcnQge3VzZVN0eWxlczIsIFNlbGVjdCB9IGZyb20gJ0BncmFmYW5hL3VpJztcbmltcG9ydCB7IHRlc3RJZHMgfSBmcm9tICcuLi9jb21wb25lbnRzL3Rlc3RJZHMnO1xuaW1wb3J0IHsgUGx1Z2luUGFnZSwgZ2V0QmFja2VuZFNydiB9IGZyb20gJ0BncmFmYW5hL3J1bnRpbWUnO1xuXG5pbXBvcnQgeyBnZXRTZXJ2aWNlTWV0cmljcywgcHJpbnRUcmVlIH0gZnJvbSAnZ2V0U2VydmljZU1ldHJpY3MnO1xuaW1wb3J0IHsgUk9VVEVTLCBPcHRpb24sIFNlcnZpY2VSZXNwb25zZSwgRGFzaGJvYXJkUmVzcG9uc2UsIE1ldHJpY0NvbXBhcmlzb24sIHN1ZmZpeFNldCB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmltcG9ydCB7IFZzY0NoZXZyb25Eb3duLCBWc2NDaGV2cm9uUmlnaHQsIFZzY0luZGVudCB9IGZyb20gXCJyZWFjdC1pY29ucy92c2NcIjtcblxuZnVuY3Rpb24gUGFnZU9uZSgpIHtcbiAgY29uc3Qgc3R5bGVzID0gdXNlU3R5bGVzMihnZXRTdHlsZXMpO1xuXG4gIC8vIFN0YXRlIGZvciBzZWxlY3RlZCBvcHRpb25zIGFuZCBhdmFpbGFibGUgb3B0aW9uc1xuICBjb25zdCBbc2VsZWN0ZWRTZXJ2aWNlLCBzZXRTZWxlY3RlZFNlcnZpY2VdID0gdXNlU3RhdGU8T3B0aW9uIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtzZWxlY3RlZERhc2hib2FyZCwgc2V0U2VsZWN0ZWREYXNoYm9hcmRdID0gdXNlU3RhdGU8T3B0aW9uIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFthdmFpbGFibGVTZXJ2aWNlcywgc2V0QXZhaWxhYmxlU2VydmljZXNdID0gdXNlU3RhdGU8T3B0aW9uW10+KFtdKTtcbiAgY29uc3QgW2F2YWlsYWJsZURhc2hib2FyZHMsIHNldEF2YWlsYWJsZURhc2hib2FyZHNdID0gdXNlU3RhdGU8T3B0aW9uW10+KFtdKTtcbiAgY29uc3QgW2xvYWRpbmdTZXJ2aWNlcywgc2V0TG9hZGluZ1NlcnZpY2VzXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2xvYWRpbmdEYXNoYm9hcmRzLCBzZXRMb2FkaW5nRGFzaGJvYXJkc10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzZXJ2aWNlRXJyb3IsIHNldFNlcnZpY2VFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2Rhc2hib2FyZEVycm9yLCBzZXREYXNoYm9hcmRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW21ldHJpY0NvbXBhcmlzb24sIHNldE1ldHJpY0NvbXBhcmlzb25dID0gdXNlU3RhdGU8TWV0cmljQ29tcGFyaXNvbiB8IG51bGw+KG51bGwpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZmV0Y2hBdmFpbGFibGVTZXJ2aWNlcygpO1xuICAgIGZldGNoQXZhaWxhYmxlRGFzaGJvYXJkcygpO1xuICB9LCBbXSk7XG4gIFxuXG4gIGNvbnN0IGZldGNoQXZhaWxhYmxlU2VydmljZXMgPSBhc3luYyAoKSA9PiB7XG4gICAgc2V0TG9hZGluZ1NlcnZpY2VzKHRydWUpO1xuICAgIHNldFNlcnZpY2VFcnJvcihudWxsKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cDovL2xvY2FsaG9zdDo5MDgwL21ldHJpY3MvZmluZD9xdWVyeT0qJyk7IC8vIFRPRE86IFRISVMgU0hPVUxEIE5PVCBCRSBIQVJEQ09ERUQuIEZJWCBUSElTLlxuICAgICAgY29uc3Qgc2VydmljZXM6IFNlcnZpY2VSZXNwb25zZVtdID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgY29uc3QgZm9ybWF0dGVkU2VydmljZXMgPSBzZXJ2aWNlcy5tYXAoKHNlcnZpY2UpID0+ICh7XG4gICAgICAgIGxhYmVsOiBzZXJ2aWNlLnRleHQsXG4gICAgICAgIHZhbHVlOiBzZXJ2aWNlLnRleHQsXG4gICAgICB9KSk7XG4gICAgICBzZXRBdmFpbGFibGVTZXJ2aWNlcyhmb3JtYXR0ZWRTZXJ2aWNlcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHNlcnZpY2VzIGZyb20gR3JhcGhpdGU6JywgZXJyb3IpO1xuICAgICAgc2V0U2VydmljZUVycm9yKCdGYWlsZWQgdG8gbG9hZCBzZXJ2aWNlcycpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nU2VydmljZXMoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBmZXRjaEF2YWlsYWJsZURhc2hib2FyZHMgPSBhc3luYyAoKSA9PiB7XG4gICAgc2V0TG9hZGluZ0Rhc2hib2FyZHModHJ1ZSk7XG4gICAgc2V0RGFzaGJvYXJkRXJyb3IobnVsbCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhc2hib2FyZHM6IERhc2hib2FyZFJlc3BvbnNlW10gPSBhd2FpdCBnZXRCYWNrZW5kU3J2KCkuZ2V0KCcvYXBpL3NlYXJjaCcpO1xuICAgICAgY29uc3QgZm9ybWF0dGVkRGFzaGJvYXJkcyA9IGRhc2hib2FyZHMubWFwKChkYXNoKSA9PiAoe1xuICAgICAgICBsYWJlbDogZGFzaC50aXRsZSxcbiAgICAgICAgdmFsdWU6IGRhc2gudWlkLFxuICAgICAgfSkpO1xuICAgICAgc2V0QXZhaWxhYmxlRGFzaGJvYXJkcyhmb3JtYXR0ZWREYXNoYm9hcmRzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgZGFzaGJvYXJkczonLCBlcnJvcik7XG4gICAgICBzZXREYXNoYm9hcmRFcnJvcignRmFpbGVkIHRvIGxvYWQgZGFzaGJvYXJkcycpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nRGFzaGJvYXJkcyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIGFzeW5jIGZ1bmN0aW9uIGdldFVzZWRNZXRyaWNzKCkge1xuICAgIGlmICghc2VsZWN0ZWRTZXJ2aWNlIHx8ICFzZWxlY3RlZERhc2hib2FyZCApIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJSZXF1aXJlZCBzZWxlY3Rpb25zIG9yIGZvcm1hdHRlZCBtZXRyaWNzIGFyZSBtaXNzaW5nLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRmV0Y2ggdGhlIHNlbGVjdGVkIGRhc2hib2FyZCBkYXRhIHRvIGdldCBtZXRyaWNzXG4gICAgY29uc3QgZGFzaGJvYXJkID0gYXdhaXQgZ2V0QmFja2VuZFNydigpLmdldChgL2FwaS9kYXNoYm9hcmRzL3VpZC8ke3NlbGVjdGVkRGFzaGJvYXJkLnZhbHVlfWApO1xuICAgIGNvbnN0IGRhc2hib2FyZFBhbmVscyA9IGRhc2hib2FyZC5kYXNoYm9hcmQucGFuZWxzIHx8IFtdO1xuXG4gICAgbGV0IHVzZWRNZXRyaWNzU2V0OiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKTtcblxuICAgIGRhc2hib2FyZFBhbmVscy5mb3JFYWNoKChwYW5lbDogYW55KSA9PiB7XG4gICAgICBpZiAocGFuZWwudGFyZ2V0cyAmJiBBcnJheS5pc0FycmF5KHBhbmVsLnRhcmdldHMpKSB7XG4gICAgICAgIHBhbmVsLnRhcmdldHMuZm9yRWFjaCgodGFyZ2V0OiBhbnkpID0+IHtcbiAgICAgICAgICBpZiAodGFyZ2V0LnRhcmdldCkge1xuICAgICAgICAgICAgbGV0IHRhcmdldE1ldHJpYyA9IHRhcmdldC50YXJnZXQ7XG4gICAgXG4gICAgICAgICAgICAvLyBSZWd1bGFyIGV4cHJlc3Npb24gdG8gbWF0Y2ggYW55IGZ1bmN0aW9uIGF0IHRoZSBzdGFydCwgZm9sbG93ZWQgYnkgYSBtZXRyaWMgbmFtZVxuICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25SZWdleCA9IC9eW2EtekEtWjAtOV9dK1xcKCguKj8pXFwpJC87XG4gICAgXG4gICAgICAgICAgICAvLyBJZiB0aGUgdGFyZ2V0IG1ldHJpYyBzdGFydHMgd2l0aCBhIGZ1bmN0aW9uLCByZW1vdmUgaXQgYW5kIHJldGFpbiB0aGUgbWV0cmljIG5hbWVcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdGFyZ2V0TWV0cmljLm1hdGNoKGZ1bmN0aW9uUmVnZXgpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIHBhcnQgaW5zaWRlIHRoZSBwYXJlbnRoZXNlcyAodGhlIGFjdHVhbCBtZXRyaWMgbmFtZSlcbiAgICAgICAgICAgICAgdGFyZ2V0TWV0cmljID0gbWF0Y2hbMV07XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAvLyBVc2UgcmVnZXggdG8gY2hlY2sgaWYgdGhlIHRhcmdldCBtZXRyaWMgYmVsb25ncyB0byB0aGUgc2VsZWN0ZWQgc2VydmljZVxuICAgICAgICAgICAgY29uc3Qgc2VydmljZVJlZ2V4ID0gbmV3IFJlZ0V4cChgKF58W15hLXpBLVowLTlfXSkke3NlbGVjdGVkU2VydmljZS52YWx1ZX0oW15hLXpBLVowLTlfXXwkKWApO1xuICAgICAgICAgICAgaWYgKHNlcnZpY2VSZWdleC50ZXN0KHRhcmdldE1ldHJpYykpIHtcbiAgICAgICAgICAgICAgdXNlZE1ldHJpY3NTZXQuYWRkKHRhcmdldE1ldHJpYyk7ICAvLyBBZGQgdGhlIG1ldHJpYyB3aXRob3V0IHRoZSBmdW5jdGlvbiB3cmFwcGVyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBDb21wYXJlIGF2YWlsYWJsZSBtZXRyaWNzIHdpdGggdGhlIHVzZWQgbWV0cmljc1xuICAgIGxldCB1c2VkTWV0cmljc0FycmF5ID0gQXJyYXkuZnJvbSh1c2VkTWV0cmljc1NldCk7XG4gICAgdXNlZE1ldHJpY3NBcnJheSA9IHJlbW92ZVJlZHVuZGFudFN1ZmZpeGVzKHVzZWRNZXRyaWNzQXJyYXkpO1xuXG4gICAgY29uc29sZS5sb2coYHVzZWQgTWV0cmljcyBBcnJheSAke3VzZWRNZXRyaWNzQXJyYXl9YCk7XG4gICAgcmV0dXJuIHVzZWRNZXRyaWNzQXJyYXk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBjb21wYXJlTWV0cmljcyhmb3JtYXR0ZWRNZXRyaWNzOiBzdHJpbmdbXSwgbWV0cmljVHJlZTogUmVjb3JkPHN0cmluZywgYW55Pik6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghc2VsZWN0ZWRTZXJ2aWNlIHx8ICFzZWxlY3RlZERhc2hib2FyZCB8fCAhZm9ybWF0dGVkTWV0cmljcykge1xuICAgICAgY29uc29sZS5lcnJvcihcIlJlcXVpcmVkIHNlbGVjdGlvbnMgb3IgZm9ybWF0dGVkIG1ldHJpY3MgYXJlIG1pc3NpbmcuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIEZldGNoIGF2YWlsYWJsZSBtZXRyaWNzXG4gICAgICBjb25zdCBhdmFpbGFibGVNZXRyaWNzID0gZm9ybWF0dGVkTWV0cmljcztcbiAgICAgIGNvbnNvbGUubG9nKFwiQXZhaWxhYmxlIE1ldHJpY3M6XCIsIGF2YWlsYWJsZU1ldHJpY3MpO1xuICBcbiAgICAgIC8vIEZldGNoIHVzZWQgbWV0cmljc1xuICAgICAgbGV0IHVzZWRNZXRyaWNzID0gYXdhaXQgZ2V0VXNlZE1ldHJpY3MoKTtcbiAgICAgIGlmICghdXNlZE1ldHJpY3MpIHtcbiAgICAgICAgdXNlZE1ldHJpY3MgPSBbXTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coYFVzZWQgTWV0cmljcyAke3VzZWRNZXRyaWNzfWApO1xuXG4gICAgICBsZXQgdW51c2VkTWV0cmljczpzdHJpbmdbXSA9IG5ldyBBcnJheSgpO1xuXG4gICAgICBcbiAgICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjaGVjayBpZiBhIG1ldHJpYyBtYXRjaGVzIGFueSBvZiB0aGUgdXNlZCBtZXRyaWNzICh3aXRoIHdpbGRjYXJkIHN1cHBvcnQpXG4gICAgICBjb25zdCBtYXRjaGVzVXNlZE1ldHJpYyA9IChtZXRyaWM6IHN0cmluZywgdXNlZE1ldHJpY3M6IHN0cmluZ1tdKTogYm9vbGVhbiA9PiB7XG4gICAgICAgIHJldHVybiB1c2VkTWV0cmljcy5zb21lKCh1c2VkTWV0cmljKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlZ2V4UGF0dGVybiA9IGBeJHt1c2VkTWV0cmljLnJlcGxhY2UoL1xcLi9nLCAnXFxcXC4nKS5yZXBsYWNlKC9cXCovZywgJy4qJyl9JGA7XG4gICAgICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAocmVnZXhQYXR0ZXJuKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBUZXN0ZWQgcmVnZXggcGF0dGVybiAke3JlZ2V4UGF0dGVybn0gb24gJHttZXRyaWN9LCAke3JlZ2V4LnRlc3QobWV0cmljKX1gKTtcbiAgICAgICAgICAgIHJldHVybiByZWdleC50ZXN0KG1ldHJpYyk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIHJlZ2V4IGluIHVzZWQgbWV0cmljOlwiLCB1c2VkTWV0cmljLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZSBmdW5jdGlvbiB0byB0cmF2ZXJzZSB0aGUgbWV0cmljIHRyZWVcbiAgICAgIGNvbnN0IHRyYXZlcnNlVHJlZSA9IChub2RlOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBjdXJyZW50UGF0aDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5vZGUpIHtcbiAgICAgICAgICBjb25zdCBuZXdQYXRoID0gY3VycmVudFBhdGggPyBgJHtjdXJyZW50UGF0aH0uJHtrZXl9YCA6IGtleTtcblxuICAgICAgICAgIGlmIChub2RlW2tleV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEl0J3MgYSBsZWFmIG5vZGVcbiAgICAgICAgICAgIGlmICghbWF0Y2hlc1VzZWRNZXRyaWMobmV3UGF0aCwgdXNlZE1ldHJpY3MpKSB7XG4gICAgICAgICAgICAgIHVudXNlZE1ldHJpY3MucHVzaChuZXdQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXQncyBhIGJyYW5jaDsgcmVjdXJzZSBpbnRvIGl0XG4gICAgICAgICAgICB0cmF2ZXJzZVRyZWUobm9kZVtrZXldLCBuZXdQYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIFN0YXJ0IHRyYXZlcnNpbmcgZnJvbSB0aGUgcm9vdCBvZiB0aGUgbWV0cmljIHRyZWVcbiAgICAgIHRyYXZlcnNlVHJlZShtZXRyaWNUcmVlLCBzZWxlY3RlZFNlcnZpY2UudmFsdWUpO1xuXG4gICAgICBjb25zb2xlLmxvZyhcIlVudXNlZCBNZXRyaWNzOlwiLCB1bnVzZWRNZXRyaWNzKTtcbiAgXG4gICAgICAvLyBTZXQgdGhlIGNvbXBhcmlzb24gcmVzdWx0XG4gICAgICBzZXRNZXRyaWNDb21wYXJpc29uKHtcbiAgICAgICAgdXNlZE1ldHJpY3M6IHVzZWRNZXRyaWNzLFxuICAgICAgICB1bnVzZWRNZXRyaWNzOiB1bnVzZWRNZXRyaWNzLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjb21wYXJpbmcgbWV0cmljczpcIiwgZXJyb3IpO1xuICAgIH1cbiAgfTtcblxuXG4gIC8vIFRyaWdnZXIgY29tcGFyaXNvbiB3aGVuIGJvdGggc2VydmljZSBhbmQgZGFzaGJvYXJkIGFyZSBzZWxlY3RlZFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGZldGNoQW5kQ29tcGFyZU1ldHJpY3MgPSBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoc2VsZWN0ZWRTZXJ2aWNlICYmIHNlbGVjdGVkRGFzaGJvYXJkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0U2VydmljZU1ldHJpY3Moc2VsZWN0ZWRTZXJ2aWNlLmxhYmVsKTsgLy8gRmV0Y2ggZm9ybWF0dGVkIG1ldHJpY3NcbiAgICAgICAgICBjb25zdCBmb3JtYXR0ZWRNZXRyaWNzID0gcmVzdWx0LmZsYXRMaXN0O1xuXG4gICAgICAgICAgY29uc3QgdHJlZU1ldHJpY3M6UmVjb3JkPHN0cmluZywgYW55PiA9IHJlc3VsdC50cmVlXG4gICAgICAgICAgcHJpbnRUcmVlKHRyZWVNZXRyaWNzKTtcblxuICAgICAgICAgIGF3YWl0IGNvbXBhcmVNZXRyaWNzKGZvcm1hdHRlZE1ldHJpY3MsIHRyZWVNZXRyaWNzKTsgLy8gQ29tcGFyZSBtZXRyaWNzXG5cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBmZXRjaGluZyBvciBjb21wYXJpbmcgbWV0cmljczonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGZldGNoQW5kQ29tcGFyZU1ldHJpY3MoKTtcbiAgfSwgW3NlbGVjdGVkU2VydmljZSwgc2VsZWN0ZWREYXNoYm9hcmRdKTtcblxuICBjb25zdCByZW1vdmVSZWR1bmRhbnRTdWZmaXhlcyA9IChtZXRyaWNzOiBzdHJpbmdbXSk6IHN0cmluZ1tdID0+IHtcbiAgICAvLyByZW1vdmVzIHJlZHVuZGFudCBzdWZmaXhlcyBmcm9tIG1ldHJpYyBuYW1lc1xuICAgIGNvbnN0IGdyb3VwZWRNZXRyaWNzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgICBtZXRyaWNzLmZvckVhY2goKGxhYmVsKSA9PiB7XG4gICAgICBmb3IgKGxldCBzdWZmaXggb2Ygc3VmZml4U2V0KSB7XG4gICAgICAgIGlmIChsYWJlbC5lbmRzV2l0aChzdWZmaXgpKSB7XG4gICAgICAgICAgY29uc3QgcHJlZml4ID0gbGFiZWwuc2xpY2UoMCwgbGFiZWwubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCk7XG4gICAgICAgICAgaWYgKCFncm91cGVkTWV0cmljcy5oYXMocHJlZml4KSkge1xuICAgICAgICAgICAgZ3JvdXBlZE1ldHJpY3MuYWRkKHByZWZpeCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrOyAvLyBPbmx5IG1hdGNoIG9uZSBzdWZmaXhcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQnVpbGQgbmV3IE9wdGlvbiBvYmplY3RzIHdpdGggZm9ybWF0dGVkIGxhYmVsc1xuICAgIGNvbnN0IGZvcm1hdHRlZE1ldHJpY3M6IHN0cmluZ1tdID0gW107XG4gICAgZ3JvdXBlZE1ldHJpY3MuZm9yRWFjaCgocHJlZml4KSA9PiB7XG4gICAgICBmb3JtYXR0ZWRNZXRyaWNzLnB1c2gocHJlZml4KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZm9ybWF0dGVkTWV0cmljcztcbiAgfTtcbiAgLy8gdGFrZSBpbiBhIGZsYXQgbGlzdCBvZiBtZXRyaWNzIGFuZCBmb3JtYXQgdGhlbSBhcyBhIHRyZWUgc3RydWN0dXJlXG4gIGNvbnN0IGZvcm1hdEFzVHJlZSA9IChtZXRyaWNzOiBzdHJpbmdbXSk6IFJlY29yZDxzdHJpbmcsIGFueT4gPT4ge1xuICAgIGNvbnN0IHRyZWU6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTtcbiAgXG4gICAgbWV0cmljcy5mb3JFYWNoKChtZXRyaWMpID0+IHtcbiAgICAgIGNvbnN0IHBhcnRzID0gbWV0cmljLnNwbGl0KCcuJyk7XG4gICAgICBsZXQgY3VycmVudExldmVsID0gdHJlZTtcbiAgXG4gICAgICBwYXJ0cy5mb3JFYWNoKChwYXJ0LCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoIWN1cnJlbnRMZXZlbFtwYXJ0XSkge1xuICAgICAgICAgIGN1cnJlbnRMZXZlbFtwYXJ0XSA9IGluZGV4ID09PSBwYXJ0cy5sZW5ndGggLSAxID8gbnVsbCA6IHt9O1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRMZXZlbCA9IGN1cnJlbnRMZXZlbFtwYXJ0XTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICBcbiAgICByZXR1cm4gdHJlZTtcbiAgfTtcbiAgXG5cbiAgLy8gVHJlZSBOb2RlIENvbXBvbmVudCBpbiBSZWFjdCAoZm9yIHJlbmRlcmluZyBleHBhbmRhYmxlIGxpc3RzKVxuICBjb25zdCBUcmVlTm9kZSA9ICh7IGxhYmVsLCBjaGlsZHJlbiB9OiB7IGxhYmVsOiBzdHJpbmc7IGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlIH0pID0+IHtcbiAgICBjb25zdCBbaXNFeHBhbmRlZCwgc2V0SXNFeHBhbmRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIFxuICAgIGNvbnN0IHRvZ2dsZUV4cGFuc2lvbiA9ICgpID0+IHtcbiAgICAgIHNldElzRXhwYW5kZWQoIWlzRXhwYW5kZWQpO1xuICAgIH07XG4gIFxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IHN0eWxlPXt7IG1hcmdpbkxlZnQ6ICcyMHB4JyB9fT5cbiAgICAgICAgPGRpdlxuICAgICAgICAgIG9uQ2xpY2s9e3RvZ2dsZUV4cGFuc2lvbn1cbiAgICAgICAgICBzdHlsZT17eyBjdXJzb3I6ICdwb2ludGVyJywgZm9udFdlaWdodDogY2hpbGRyZW4gPyAnYm9sZCcgOiAnbm9ybWFsJyB9fVxuICAgICAgICA+XG4gICAgICAgICAge2NoaWxkcmVuID8gKGlzRXhwYW5kZWQgPyA8VnNjQ2hldnJvbkRvd24gLz4gOiA8VnNjQ2hldnJvblJpZ2h0IC8+KSA6IDxWc2NJbmRlbnQgLz59IHtsYWJlbH1cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIHtpc0V4cGFuZGVkICYmIGNoaWxkcmVuICYmIDxkaXY+e2NoaWxkcmVufTwvZGl2Pn1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH07XG4gIGNvbnN0IFRyZWUgPSAoeyBkYXRhIH06IHsgZGF0YTogUmVjb3JkPHN0cmluZywgYW55PiB9KSA9PiB7XG4gICAgY29uc3QgcmVuZGVyVHJlZSA9IChub2RlOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUmVhY3QuUmVhY3ROb2RlID0+IHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhub2RlKS5tYXAoKGtleSkgPT4gKFxuICAgICAgICA8VHJlZU5vZGUga2V5PXtrZXl9IGxhYmVsPXtrZXl9PlxuICAgICAgICAgIHtub2RlW2tleV0gIT09IG51bGwgJiYgdHlwZW9mIG5vZGVba2V5XSA9PT0gJ29iamVjdCcgPyByZW5kZXJUcmVlKG5vZGVba2V5XSkgOiBudWxsfVxuICAgICAgICA8L1RyZWVOb2RlPlxuICAgICAgKSk7XG4gICAgfTtcbiAgXG4gICAgcmV0dXJuIDxkaXY+e3JlbmRlclRyZWUoZGF0YSl9PC9kaXY+O1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPFBsdWdpblBhZ2U+XG4gICAgICA8ZGl2IGRhdGEtdGVzdGlkPXt0ZXN0SWRzLnBhZ2VPbmUuY29udGFpbmVyfT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5tYXJnaW5Ub3B9PlxuICAgICAgICAgIDxTZWxlY3RcbiAgICAgICAgICAgIG9wdGlvbnM9e2F2YWlsYWJsZVNlcnZpY2VzfVxuICAgICAgICAgICAgdmFsdWU9e3NlbGVjdGVkU2VydmljZX1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXtzZXRTZWxlY3RlZFNlcnZpY2V9XG4gICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlNlbGVjdCBTZXJ2aWNlXCJcbiAgICAgICAgICAgIGlzTG9hZGluZz17bG9hZGluZ1NlcnZpY2VzfVxuICAgICAgICAgIC8+XG4gICAgICAgICAge3NlcnZpY2VFcnJvciAmJiA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmVycm9yfT57c2VydmljZUVycm9yfTwvZGl2Pn1cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5tYXJnaW5Ub3B9PlxuICAgICAgICAgIDxTZWxlY3RcbiAgICAgICAgICAgIG9wdGlvbnM9e2F2YWlsYWJsZURhc2hib2FyZHN9XG4gICAgICAgICAgICB2YWx1ZT17c2VsZWN0ZWREYXNoYm9hcmR9XG4gICAgICAgICAgICBvbkNoYW5nZT17c2V0U2VsZWN0ZWREYXNoYm9hcmR9XG4gICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlNlbGVjdCBEYXNoYm9hcmRcIlxuICAgICAgICAgICAgaXNMb2FkaW5nPXtsb2FkaW5nRGFzaGJvYXJkc31cbiAgICAgICAgICAvPlxuICAgICAgICAgIHtkYXNoYm9hcmRFcnJvciAmJiA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmVycm9yfT57ZGFzaGJvYXJkRXJyb3J9PC9kaXY+fVxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICB7bWV0cmljQ29tcGFyaXNvbiAmJiAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake3N0eWxlcy5tZXRyaWNDb21wYXJpc29ufSAke3N0eWxlcy5yZXNwb25zaXZlfWB9PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5tZXRyaWNzQ29sdW1ufT5cbiAgICAgICAgICAgICAgPGg0PjxzdHJvbmc+VXNlZCBNZXRyaWNzOjwvc3Ryb25nPjwvaDQ+XG4gICAgICAgICAgICAgIDxwPnttZXRyaWNDb21wYXJpc29uLnVzZWRNZXRyaWNzLmxlbmd0aH0gbWV0cmljczwvcD5cbiAgICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgIHttZXRyaWNDb21wYXJpc29uLnVzZWRNZXRyaWNzICYmIG1ldHJpY0NvbXBhcmlzb24udXNlZE1ldHJpY3MubGVuZ3RoID4gMCA/IChcbiAgICAgICAgICAgICAgICAgIDxUcmVlIGRhdGE9e2Zvcm1hdEFzVHJlZShtZXRyaWNDb21wYXJpc29uLnVzZWRNZXRyaWNzKX0gLz5cbiAgICAgICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgICAgPHA+Tm8gdXNlZCBtZXRyaWNzLjwvcD5cbiAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLm1ldHJpY3NDb2x1bW59PlxuICAgICAgICAgICAgICA8aDQ+PHN0cm9uZz5VbnVzZWQgTWV0cmljczo8L3N0cm9uZz48L2g0PlxuICAgICAgICAgICAgICA8cD57bWV0cmljQ29tcGFyaXNvbi51bnVzZWRNZXRyaWNzLmxlbmd0aH0gbWV0cmljczwvcD5cbiAgICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgIHttZXRyaWNDb21wYXJpc29uLnVudXNlZE1ldHJpY3MgJiYgbWV0cmljQ29tcGFyaXNvbi51bnVzZWRNZXRyaWNzLmxlbmd0aCA+IDAgPyAoXG4gICAgICAgICAgICAgICAgICA8VHJlZSBkYXRhPXtmb3JtYXRBc1RyZWUobWV0cmljQ29tcGFyaXNvbi51bnVzZWRNZXRyaWNzKX0gLz5cbiAgICAgICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgICAgPHA+Tm8gdW51c2VkIG1ldHJpY3MuPC9wPlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgIDwvZGl2PlxuICAgIDwvUGx1Z2luUGFnZT5cbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFnZU9uZTtcblxuLy8gU3R5bGVzXG5jb25zdCBnZXRTdHlsZXMgPSAodGhlbWU6IEdyYWZhbmFUaGVtZTIpID0+ICh7XG4gIG1hcmdpblRvcDogY3NzYFxuICAgIG1hcmdpbi10b3A6ICR7dGhlbWUuc3BhY2luZygyKX07XG4gIGAsXG4gIGVycm9yOiBjc3NgXG4gICAgY29sb3I6ICR7dGhlbWUuY29sb3JzLmVycm9yLnRleHR9O1xuICAgIG1hcmdpbi10b3A6ICR7dGhlbWUuc3BhY2luZygxKX07XG4gIGAsXG4gIG1ldHJpY0NvbXBhcmlzb246IGNzc2BcbiAgICBtYXJnaW4tdG9wOiAke3RoZW1lLnNwYWNpbmcoMSl9O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZ2FwOiAke3RoZW1lLnNwYWNpbmcoNCl9O1xuICAgIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgYCxcbiAgbWV0cmljc0NvbHVtbjogY3NzYFxuICAgIG1hcmdpbi10b3A6ICR7dGhlbWUuc3BhY2luZygxKX07XG4gICAgZmxleDogMTtcbiAgICBtaW4td2lkdGg6IDIwMHB4O1xuICBgLFxuICByZXNwb25zaXZlOiBjc3NgXG4gICAgQG1lZGlhIChtYXgtd2lkdGg6IDc2OHB4KSB7XG4gICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIH1cbiAgYCxcbn0pO1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJjc3MiLCJ1c2VTdHlsZXMyIiwiU2VsZWN0IiwidGVzdElkcyIsIlBsdWdpblBhZ2UiLCJnZXRCYWNrZW5kU3J2IiwiZ2V0U2VydmljZU1ldHJpY3MiLCJwcmludFRyZWUiLCJzdWZmaXhTZXQiLCJWc2NDaGV2cm9uRG93biIsIlZzY0NoZXZyb25SaWdodCIsIlZzY0luZGVudCIsIlBhZ2VPbmUiLCJzdHlsZXMiLCJnZXRTdHlsZXMiLCJzZWxlY3RlZFNlcnZpY2UiLCJzZXRTZWxlY3RlZFNlcnZpY2UiLCJzZWxlY3RlZERhc2hib2FyZCIsInNldFNlbGVjdGVkRGFzaGJvYXJkIiwiYXZhaWxhYmxlU2VydmljZXMiLCJzZXRBdmFpbGFibGVTZXJ2aWNlcyIsImF2YWlsYWJsZURhc2hib2FyZHMiLCJzZXRBdmFpbGFibGVEYXNoYm9hcmRzIiwibG9hZGluZ1NlcnZpY2VzIiwic2V0TG9hZGluZ1NlcnZpY2VzIiwibG9hZGluZ0Rhc2hib2FyZHMiLCJzZXRMb2FkaW5nRGFzaGJvYXJkcyIsInNlcnZpY2VFcnJvciIsInNldFNlcnZpY2VFcnJvciIsImRhc2hib2FyZEVycm9yIiwic2V0RGFzaGJvYXJkRXJyb3IiLCJtZXRyaWNDb21wYXJpc29uIiwic2V0TWV0cmljQ29tcGFyaXNvbiIsImZldGNoQXZhaWxhYmxlU2VydmljZXMiLCJmZXRjaEF2YWlsYWJsZURhc2hib2FyZHMiLCJyZXNwb25zZSIsImZldGNoIiwic2VydmljZXMiLCJqc29uIiwiZm9ybWF0dGVkU2VydmljZXMiLCJtYXAiLCJzZXJ2aWNlIiwibGFiZWwiLCJ0ZXh0IiwidmFsdWUiLCJlcnJvciIsImNvbnNvbGUiLCJkYXNoYm9hcmRzIiwiZ2V0IiwiZm9ybWF0dGVkRGFzaGJvYXJkcyIsImRhc2giLCJ0aXRsZSIsInVpZCIsImdldFVzZWRNZXRyaWNzIiwiZGFzaGJvYXJkIiwiZGFzaGJvYXJkUGFuZWxzIiwicGFuZWxzIiwidXNlZE1ldHJpY3NTZXQiLCJTZXQiLCJmb3JFYWNoIiwicGFuZWwiLCJ0YXJnZXRzIiwiQXJyYXkiLCJpc0FycmF5IiwidGFyZ2V0IiwidGFyZ2V0TWV0cmljIiwiZnVuY3Rpb25SZWdleCIsIm1hdGNoIiwic2VydmljZVJlZ2V4IiwiUmVnRXhwIiwidGVzdCIsImFkZCIsInVzZWRNZXRyaWNzQXJyYXkiLCJmcm9tIiwicmVtb3ZlUmVkdW5kYW50U3VmZml4ZXMiLCJsb2ciLCJjb21wYXJlTWV0cmljcyIsImZvcm1hdHRlZE1ldHJpY3MiLCJtZXRyaWNUcmVlIiwiYXZhaWxhYmxlTWV0cmljcyIsInVzZWRNZXRyaWNzIiwidW51c2VkTWV0cmljcyIsIm1hdGNoZXNVc2VkTWV0cmljIiwibWV0cmljIiwic29tZSIsInVzZWRNZXRyaWMiLCJyZWdleFBhdHRlcm4iLCJyZXBsYWNlIiwicmVnZXgiLCJ0cmF2ZXJzZVRyZWUiLCJub2RlIiwiY3VycmVudFBhdGgiLCJrZXkiLCJuZXdQYXRoIiwicHVzaCIsImZldGNoQW5kQ29tcGFyZU1ldHJpY3MiLCJyZXN1bHQiLCJmbGF0TGlzdCIsInRyZWVNZXRyaWNzIiwidHJlZSIsIm1ldHJpY3MiLCJncm91cGVkTWV0cmljcyIsInN1ZmZpeCIsImVuZHNXaXRoIiwicHJlZml4Iiwic2xpY2UiLCJsZW5ndGgiLCJoYXMiLCJmb3JtYXRBc1RyZWUiLCJwYXJ0cyIsInNwbGl0IiwiY3VycmVudExldmVsIiwicGFydCIsImluZGV4IiwiVHJlZU5vZGUiLCJjaGlsZHJlbiIsImlzRXhwYW5kZWQiLCJzZXRJc0V4cGFuZGVkIiwidG9nZ2xlRXhwYW5zaW9uIiwiZGl2Iiwic3R5bGUiLCJtYXJnaW5MZWZ0Iiwib25DbGljayIsImN1cnNvciIsImZvbnRXZWlnaHQiLCJUcmVlIiwiZGF0YSIsInJlbmRlclRyZWUiLCJPYmplY3QiLCJrZXlzIiwiZGF0YS10ZXN0aWQiLCJwYWdlT25lIiwiY29udGFpbmVyIiwiY2xhc3NOYW1lIiwibWFyZ2luVG9wIiwib3B0aW9ucyIsIm9uQ2hhbmdlIiwicGxhY2Vob2xkZXIiLCJpc0xvYWRpbmciLCJyZXNwb25zaXZlIiwibWV0cmljc0NvbHVtbiIsImg0Iiwic3Ryb25nIiwicCIsInVsIiwidGhlbWUiLCJzcGFjaW5nIiwiY29sb3JzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./pages/PageOne.tsx\n");

/***/ })

}]);