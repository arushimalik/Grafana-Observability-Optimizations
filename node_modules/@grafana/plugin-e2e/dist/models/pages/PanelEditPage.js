"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PanelEditPage = void 0;
const semver = __importStar(require("semver"));
const test_1 = require("@playwright/test");
const DataSourcePicker_1 = require("../components/DataSourcePicker");
const GrafanaPage_1 = require("./GrafanaPage");
const TimeRange_1 = require("../components/TimeRange");
const Panel_1 = require("../components/Panel");
const utils_1 = require("../utils");
const DashboardPage_1 = require("./DashboardPage");
class PanelEditPage extends GrafanaPage_1.GrafanaPage {
    ctx;
    args;
    datasource;
    timeRange;
    panel;
    constructor(ctx, args) {
        super(ctx, args);
        this.ctx = ctx;
        this.args = args;
        this.datasource = new DataSourcePicker_1.DataSourcePicker(ctx);
        this.timeRange = new TimeRange_1.TimeRange(ctx);
        this.panel = new Panel_1.Panel(ctx, this.getPanelLocator());
    }
    getPanelLocator() {
        // only one panel is allowed in the panel edit page, so we don't need to use panel title to locate it
        const locator = this.getByGrafanaSelector(this.ctx.selectors.components.Panels.Panel.title(''), {
            startsWith: true,
        });
        // in older versions, the panel selector is added to a child element, so we need to go up two levels to get the wrapper
        if (semver.lt(this.ctx.grafanaVersion, '9.5.0')) {
            return locator.locator('..').locator('..');
        }
        return locator;
    }
    /**
     * Navigates to the panel edit page. If a dashboard uid was not provided, it's assumed that it's a new dashboard.
     */
    async goto(options) {
        const url = this.args.dashboard?.uid
            ? this.ctx.selectors.pages.Dashboard.url(this.args.dashboard.uid)
            : this.ctx.selectors.pages.AddDashboard.url;
        options ??= {};
        options.queryParams ??= new URLSearchParams();
        options.queryParams.append('editPanel', this.args.id);
        await super.navigate(url, options);
    }
    async toggleTableView() {
        await (0, utils_1.radioButtonSetChecked)(this.ctx.page, 'Table view', true);
        let locator = this.getByGrafanaSelector(this.ctx.selectors.components.Panels.Panel.toggleTableViewPanel(''));
        if (semver.lt(this.ctx.grafanaVersion, '10.4.0')) {
            locator = this.ctx.page.getByRole('table');
        }
        this.panel = new Panel_1.Panel(this.ctx, locator);
    }
    async untoggleTableView() {
        await (0, utils_1.radioButtonSetChecked)(this.ctx.page, 'Table view', false);
        this.panel = new Panel_1.Panel(this.ctx, this.getByGrafanaSelector(this.ctx.selectors.components.Panels.Panel.title(''), { startsWith: true }));
    }
    /**
     * Sets the title of the panel. This method will open the panel options, set the title and close the panel options.
     */
    async setPanelTitle(titleText) {
        const TITLE = 'Title';
        const { OptionsGroup, PanelEditor } = this.ctx.selectors.components;
        await this.collapseSection(OptionsGroup.groupTitle);
        const vizInput = semver.gte(this.ctx.grafanaVersion, '11.0.0')
            ? this.getByGrafanaSelector(PanelEditor.OptionsPane.fieldInput(TITLE))
            : this.getByGrafanaSelector(OptionsGroup.group(OptionsGroup.groupTitle)).locator('input').first();
        await vizInput.fill(titleText);
        await this.ctx.page.keyboard.press('Tab');
    }
    /**
     * Sets the visualization for the panel. This method will open the visualization picker, select the given visualization
     */
    async setVisualization(visualization) {
        // toggle options pane if panel edit is not visible
        const showPanelEditElement = this.getByGrafanaSelector('Show options pane');
        const showPanelEditElementCount = await showPanelEditElement.count();
        if (showPanelEditElementCount > 0) {
            await showPanelEditElement.click();
        }
        await this.getByGrafanaSelector(this.ctx.selectors.components.PanelEditor.toggleVizPicker).click();
        await this.getByGrafanaSelector(this.ctx.selectors.components.PluginVisualization.item(visualization)).click();
        await (0, test_1.expect)(this.getByGrafanaSelector(this.ctx.selectors.components.PanelEditor.toggleVizPicker), `Could not set visualization to ${visualization}. Ensure the panel is installed.`).toHaveText(visualization);
    }
    /**
     * Expands the section for the given category name. If the section is already expanded, this method does nothing.
     */
    async collapseSection(categoryName) {
        const section = this.getByGrafanaSelector(this.ctx.selectors.components.OptionsGroup.group(categoryName));
        await (0, test_1.expect)(section, `Could not find any section for category: ${categoryName}`).toBeVisible();
        const sectionToggle = this.getByGrafanaSelector(this.ctx.selectors.components.OptionsGroup.toggle(categoryName));
        const expandedAttr = (await sectionToggle.getAttribute('aria-expanded')) ?? '';
        if (/false/.test(expandedAttr)) {
            await section.click();
        }
    }
    /**
     * Returns the name of the visualization currently selected in the panel editor
     */
    getVisualizationName() {
        return this.getByGrafanaSelector(this.ctx.selectors.components.PanelEditor.toggleVizPicker);
    }
    /**
     * Clicks the "Back to dashboard" button in the panel editor
     * In versions prior to 11.3.0, this method clicks the "Apply" button instead
     */
    async backToDashboard() {
        if (semver.gte(this.ctx.grafanaVersion, '11.3.0')) {
            await this.getByGrafanaSelector(this.ctx.selectors.components.NavToolbar.editDashboard.backToDashboardButton).click();
        }
        else if (semver.gte(this.ctx.grafanaVersion, '9.0.0')) {
            await this.ctx.page.getByTestId(this.ctx.selectors.components.PanelEditor.applyButton).click();
        }
        else {
            await this.ctx.page.getByLabel('panel editor apply').click();
        }
        return new DashboardPage_1.DashboardPage(this.ctx, this.args);
    }
    /**
     * Clicks the "Apply" button in the panel editor
     *
     * @deprecated use {@link PanelEditPage.backToDashboard} method instead.
     */
    async apply() {
        return this.backToDashboard();
    }
    /**
     * Returns the locator for the query editor row with the given refId
     */
    getQueryEditorRow(refId) {
        return this.getByGrafanaSelector(this.ctx.selectors.components.QueryEditorRows.rows).filter({
            has: this.getByGrafanaSelector(this.ctx.selectors.components.QueryEditorRow.title(refId)),
        });
    }
    /**
     * Clicks the "Refresh" button in the panel editor. Returns the response promise for the data query
     *
     * By default, this method will wait for any response that has the url '/api/ds/query'.
     * If you need to wait for a specific response, you can pass a callback to the `waitForResponsePredicateCallback` option.
     * e.g
     * panelEditPage.refreshPanel({
        waitForResponsePredicateCallback: (r) =>
          r.url().includes(selectors.apis.DataSource.query) &&
          r.body().then((body) => body.includes(`"status":"finished"`)),
      })
     */
    async refreshPanel(options) {
        const defaultPredicate = (resp) => resp.url().includes(this.ctx.selectors.apis.DataSource.query);
        const responsePromise = this.ctx.page.waitForResponse(options?.waitForResponsePredicateCallback ?? defaultPredicate, options);
        // in older versions of grafana, the refresh button is rendered twice. this is a workaround to click the correct one
        const refreshPanelButton = this.getByGrafanaSelector(this.ctx.selectors.components.RefreshPicker.runButtonV2, {
            root: this.getByGrafanaSelector(this.ctx.selectors.components.PanelEditor.General.content),
        });
        await refreshPanelButton.click();
        return responsePromise;
    }
}
exports.PanelEditPage = PanelEditPage;
